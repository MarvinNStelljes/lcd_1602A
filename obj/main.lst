   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	set_bits
  12               	set_bits:
  13               	.LFB12:
  14               		.file 1 "main.c"
   1:main.c        **** /* Alle Zeichen zwischen Schrägstrich-Stern 
   2:main.c        ****    und Stern-Schrägstrich sind Kommentare */
   3:main.c        **** 
   4:main.c        **** // Zeilenkommentare sind ebenfalls möglich
   5:main.c        **** // alle auf die beiden Schrägstriche folgenden
   6:main.c        **** // Zeichen einer Zeile sind Kommentar
   7:main.c        **** 
   8:main.c        **** 
   9:main.c        **** 
  10:main.c        **** #include "lcd_1602A.h"
  11:main.c        **** #include "main.h"
  12:main.c        **** #include <avr/io.h> 
  13:main.c        **** #include <util/delay.h>
  14:main.c        **** #include <stdio.h>
  15:main.c        **** #include <stdlib.h>
  16:main.c        **** #include <stdint.h>
  17:main.c        **** #include <stdarg.h>
  18:main.c        **** //#include <avr/io.h>          // (1)
  19:main.c        **** //#include <util/delay.h>
  20:main.c        **** 
  21:main.c        **** 
  22:main.c        **** //#include "lcd_1602A.h"
  23:main.c        **** 
  24:main.c        **** 
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** /*
  28:main.c        **** void set_bits(unsigned char *reg, unsigned char num, int first_bit, ...);
  29:main.c        **** void clear_bits(unsigned char *reg, unsigned char num, int first_bit, ...);
  30:main.c        **** void lcd_write(unsigned char character);
  31:main.c        **** void lcd_write_string(unsigned char *string);
  32:main.c        **** void put_lcd_data(uint8_t data);
  33:main.c        **** void put_lcd_nibble(uint8_t data);
  34:main.c        **** 
  35:main.c        **** */
  36:main.c        **** 
  37:main.c        **** 
  38:main.c        **** int main (void) {   
  39:main.c        **** 	
  40:main.c        **** 	_delay_ms (20);
  41:main.c        **** 		DDRB = 0xFF;             // (3)
  42:main.c        ****             
  43:main.c        **** 	DDRD = 0xFF;         // (2)
  44:main.c        **** 
  45:main.c        ****   
  46:main.c        ****  
  47:main.c        ****     clear_bits(&PORTD, 2, RS_PIN, RW_PIN);
  48:main.c        ****    _delay_ms (10); 
  49:main.c        ****    
  50:main.c        **** put_lcd_nibble(0x03);
  51:main.c        **** _delay_ms (4.1);
  52:main.c        **** 
  53:main.c        **** put_lcd_nibble(0x03);
  54:main.c        **** _delay_us (100);
  55:main.c        **** 
  56:main.c        ****               
  57:main.c        **** 
  58:main.c        **** 
  59:main.c        **** 
  60:main.c        **** put_lcd_nibble(0x03);
  61:main.c        **** _delay_ms (4.1);
  62:main.c        **** put_lcd_nibble(0x02);
  63:main.c        **** _delay_ms (4.1);
  64:main.c        **** 
  65:main.c        **** put_lcd_data(LCD_FUNCTION_SET | LCD_SET_4BIT_MODE | LCD_SET_2LINE_MODE | LCD_FONT_5X8_MODE);	
  66:main.c        **** 
  67:main.c        **** put_lcd_data(LCD_DISPLAY_OFF);
  68:main.c        **** 
  69:main.c        **** put_lcd_data(LCD_CLEAR_DISPLAY);	
  70:main.c        **** 
  71:main.c        **** //Entry Mode
  72:main.c        **** 
  73:main.c        **** put_lcd_data(LCD_ENTRY_MODE | LCD_CURSOR_INC_DIR_RIGHT| LCD_SHIFT_OFF);
  74:main.c        **** 
  75:main.c        **** 
  76:main.c        **** put_lcd_data(LCD_DISPLAY_ON | LCD_CURSOR_ON | LCD_CURSOR_BLINK_ON);
  77:main.c        **** 
  78:main.c        **** //----------------------------------------------------------------------
  79:main.c        **** 	uint8_t formatted_string[40];
  80:main.c        **** 
  81:main.c        **** int zahl = 0x55;
  82:main.c        **** 
  83:main.c        **** 
  84:main.c        **** 
  85:main.c        **** 
  86:main.c        ****    	lcd_write_string("Na das war aber eine schwere Geburt");
  87:main.c        ****    	 _delay_ms (2000);
  88:main.c        ****          
  89:main.c        ****    	put_lcd_data(LCD_CLEAR_DISPLAY);
  90:main.c        ****   
  91:main.c        ****    	
  92:main.c        **** 	lcd_write_string("Und das alles wegen einem schlechten Datenblatt...");
  93:main.c        **** 	_delay_ms (2000);
  94:main.c        **** 	put_lcd_data(LCD_CLEAR_DISPLAY);
  95:main.c        **** 	
  96:main.c        **** 	
  97:main.c        **** 	sprintf(formatted_string, "DMSG: PORTB:%x",PORTB);
  98:main.c        **** 	lcd_write_string(formatted_string);
  99:main.c        **** 	_delay_ms (2000);
 100:main.c        **** 	
 101:main.c        **** 		
 102:main.c        **** 	DDRB &=	~(1 << SENSOR);
 103:main.c        **** 	_delay_ms (20);
 104:main.c        **** 	
 105:main.c        **** 		
 106:main.c        **** 	put_lcd_data(LCD_CLEAR_DISPLAY);	
 107:main.c        **** 		
 108:main.c        **** 		
 109:main.c        **** 	while(1) {                
 110:main.c        ****      
 111:main.c        ****         debug_pin(PORTB0);
 112:main.c        ****         
 113:main.c        **** 	sprintf(formatted_string, "SENSOR: %x",(PINB & (1 << PINB2)));
 114:main.c        **** 	lcd_write_string(formatted_string);
 115:main.c        **** 	
 116:main.c        **** 	put_lcd_data(LCD_CARRIAGE_RETURN);
 117:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 118:main.c        **** 	
 119:main.c        **** 	_delay_ms (1000);	
 120:main.c        ****         
 121:main.c        ****         
 122:main.c        ****    }        
 123:main.c        **** 		
 124:main.c        **** 		
 125:main.c        **** 	
 126:main.c        **** 	
 127:main.c        ****    while(1) {                
 128:main.c        ****      
 129:main.c        ****         debug_pin(PORTB0);
 130:main.c        ****    }                        
 131:main.c        **** 
 132:main.c        ****    /* wird nie erreicht */
 133:main.c        ****    return 0;                 
 134:main.c        **** }
 135:main.c        **** 
 136:main.c        **** 
 137:main.c        **** 
 138:main.c        **** 
 139:main.c        **** 
 140:main.c        **** 
 141:main.c        **** void set_bits(unsigned char *reg, unsigned char num, int first_bit, ...) 
 142:main.c        **** {
  15               		.loc 1 142 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30               	/* prologue: function */
  31               	/* frame size = 0 */
  32               	/* stack size = 2 */
  33               	.L__stack_usage = 2
  34 0008 ED81      		ldd r30,Y+5
  35 000a FE81      		ldd r31,Y+6
  36 000c 2F81      		ldd r18,Y+7
 143:main.c        **** 	va_list pointer;
 144:main.c        **** 	 
 145:main.c        **** 	*reg |= (1 << first_bit);
  37               		.loc 1 145 0
  38 000e 81E0      		ldi r24,lo8(1)
  39 0010 90E0      		ldi r25,0
  40 0012 0884      		ldd r0,Y+8
  41 0014 00C0      		rjmp 2f
  42               		1:
  43 0016 880F      		lsl r24
  44 0018 991F      		rol r25
  45               		2:
  46 001a 0A94      		dec r0
  47 001c 02F4      		brpl 1b
  48 001e 9081      		ld r25,Z
  49 0020 892B      		or r24,r25
  50 0022 8083      		st Z,r24
 146:main.c        **** 	
 147:main.c        **** 	if (num >1) {
  51               		.loc 1 147 0
  52 0024 2230      		cpi r18,lo8(2)
  53 0026 00F0      		brlo .L1
  54               	.LVL1:
  55 0028 DE01      		movw r26,r28
  56 002a 1A96      		adiw r26,10
 148:main.c        **** 	
 149:main.c        **** 		va_start(pointer, first_bit);
 150:main.c        **** 		
 151:main.c        **** 		while((num-1) > 0)  {
 152:main.c        **** 			*reg |= (1 << va_arg(pointer, int));
  57               		.loc 1 152 0
  58 002c 41E0      		ldi r20,lo8(1)
  59 002e 50E0      		ldi r21,0
  60               	.LVL2:
  61               	.L3:
 151:main.c        **** 			*reg |= (1 << va_arg(pointer, int));
  62               		.loc 1 151 0
  63 0030 822F      		mov r24,r18
  64 0032 90E0      		ldi r25,0
  65 0034 0297      		sbiw r24,2
  66 0036 04F0      		brlt .L1
  67               		.loc 1 152 0
  68 0038 8C91      		ld r24,X
  69 003a 1296      		adiw r26,2
  70 003c BA01      		movw r22,r20
  71 003e 00C0      		rjmp 2f
  72               		1:
  73 0040 660F      		lsl r22
  74 0042 771F      		rol r23
  75               		2:
  76 0044 8A95      		dec r24
  77 0046 02F4      		brpl 1b
  78 0048 CB01      		movw r24,r22
  79 004a 9081      		ld r25,Z
  80 004c 892B      		or r24,r25
  81 004e 8083      		st Z,r24
 153:main.c        **** 			num--;
  82               		.loc 1 153 0
  83 0050 2150      		subi r18,lo8(-(-1))
  84               	.LVL3:
  85 0052 00C0      		rjmp .L3
  86               	.LVL4:
  87               	.L1:
  88               	/* epilogue start */
 154:main.c        **** 		}
 155:main.c        **** 		va_end(pointer);
 156:main.c        **** 	}
 157:main.c        **** }
  89               		.loc 1 157 0
  90 0054 DF91      		pop r29
  91 0056 CF91      		pop r28
  92 0058 0895      		ret
  93               		.cfi_endproc
  94               	.LFE12:
  96               	.global	clear_bits
  98               	clear_bits:
  99               	.LFB13:
 158:main.c        **** 	
 159:main.c        **** 	void clear_bits(unsigned char *reg, unsigned char num, int first_bit, ...) 
 160:main.c        **** {
 100               		.loc 1 160 0
 101               		.cfi_startproc
 102               	.LVL5:
 103 005a CF93      		push r28
 104               	.LCFI3:
 105               		.cfi_def_cfa_offset 3
 106               		.cfi_offset 28, -2
 107 005c DF93      		push r29
 108               	.LCFI4:
 109               		.cfi_def_cfa_offset 4
 110               		.cfi_offset 29, -3
 111 005e CDB7      		in r28,__SP_L__
 112 0060 DEB7      		in r29,__SP_H__
 113               	.LCFI5:
 114               		.cfi_def_cfa_register 28
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 2 */
 118               	.L__stack_usage = 2
 119 0062 ED81      		ldd r30,Y+5
 120 0064 FE81      		ldd r31,Y+6
 121 0066 2F81      		ldd r18,Y+7
 161:main.c        **** 	va_list pointer;
 162:main.c        **** 	
 163:main.c        **** 	*reg &= ~(1 << first_bit);
 122               		.loc 1 163 0
 123 0068 81E0      		ldi r24,lo8(1)
 124 006a 90E0      		ldi r25,0
 125 006c 0884      		ldd r0,Y+8
 126 006e 00C0      		rjmp 2f
 127               		1:
 128 0070 880F      		lsl r24
 129 0072 991F      		rol r25
 130               		2:
 131 0074 0A94      		dec r0
 132 0076 02F4      		brpl 1b
 133 0078 8095      		com r24
 134 007a 9081      		ld r25,Z
 135 007c 8923      		and r24,r25
 136 007e 8083      		st Z,r24
 164:main.c        **** 	 
 165:main.c        **** 	if (num >1) {
 137               		.loc 1 165 0
 138 0080 2230      		cpi r18,lo8(2)
 139 0082 00F0      		brlo .L6
 140               	.LVL6:
 141 0084 DE01      		movw r26,r28
 142 0086 1A96      		adiw r26,10
 166:main.c        **** 		
 167:main.c        **** 		va_start(pointer, first_bit);
 168:main.c        **** 		
 169:main.c        **** 		while(num > 0)  {
 170:main.c        **** 			*reg &= ~(1 << va_arg(pointer, int));
 143               		.loc 1 170 0
 144 0088 41E0      		ldi r20,lo8(1)
 145 008a 50E0      		ldi r21,0
 146               	.LVL7:
 147               	.L8:
 148 008c 8C91      		ld r24,X
 149 008e 1296      		adiw r26,2
 150 0090 BA01      		movw r22,r20
 151 0092 00C0      		rjmp 2f
 152               		1:
 153 0094 660F      		lsl r22
 154 0096 771F      		rol r23
 155               		2:
 156 0098 8A95      		dec r24
 157 009a 02F4      		brpl 1b
 158 009c CB01      		movw r24,r22
 159 009e 8095      		com r24
 160 00a0 9095      		com r25
 161 00a2 9081      		ld r25,Z
 162 00a4 8923      		and r24,r25
 163 00a6 8083      		st Z,r24
 171:main.c        **** 			num--;
 164               		.loc 1 171 0
 165 00a8 2150      		subi r18,lo8(-(-1))
 166               	.LVL8:
 169:main.c        **** 			*reg &= ~(1 << va_arg(pointer, int));
 167               		.loc 1 169 0
 168 00aa 01F4      		brne .L8
 169               	.LVL9:
 170               	.L6:
 171               	/* epilogue start */
 172:main.c        **** 		}
 173:main.c        **** 		va_end(pointer);
 174:main.c        **** 	}
 175:main.c        **** }
 172               		.loc 1 175 0
 173 00ac DF91      		pop r29
 174 00ae CF91      		pop r28
 175 00b0 0895      		ret
 176               		.cfi_endproc
 177               	.LFE13:
 179               	.global	put_lcd_data
 181               	put_lcd_data:
 182               	.LFB16:
 176:main.c        **** 	
 177:main.c        **** 	void lcd_write(unsigned char character)
 178:main.c        **** 	{
 179:main.c        **** 		
 180:main.c        **** 		
 181:main.c        **** 			 set_bits(&RS_PORT, 1, RS_PIN); 
 182:main.c        **** 	
 183:main.c        ****    _delay_ms (1); 
 184:main.c        **** 	
 185:main.c        **** 	 put_lcd_data(character);
 186:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 187:main.c        **** 
 188:main.c        **** 	
 189:main.c        **** 		
 190:main.c        **** 	
 191:main.c        **** 		
 192:main.c        **** 	clear_bits(&RS_PORT, 1, RS_PIN);
 193:main.c        **** 	
 194:main.c        **** 
 195:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 196:main.c        **** }
 197:main.c        **** 	
 198:main.c        **** 
 199:main.c        **** void lcd_write_string(unsigned char *string)
 200:main.c        **** {
 201:main.c        **** 	int cnt = 0; 
 202:main.c        **** 	
 203:main.c        **** 	while(*string != 0) {
 204:main.c        **** 			
 205:main.c        **** 		set_bits(&RS_PORT, 1, RS_PIN); 
 206:main.c        **** 		
 207:main.c        **** 		_delay_ms (1);
 208:main.c        **** 		
 209:main.c        **** 		put_lcd_data(*string);
 210:main.c        **** 		//while(get_lcd_busy_flag() > 0);	
 211:main.c        **** 					
 212:main.c        **** 		clear_bits(&RS_PORT, 1, RS_PIN);
 213:main.c        **** 			
 214:main.c        **** 		if (cnt == 15)
 215:main.c        **** 		{
 216:main.c        **** 			//carriage return
 217:main.c        **** 		
 218:main.c        **** 		put_lcd_data(LCD_CARRIAGE_RETURN);
 219:main.c        **** 		//while(get_lcd_busy_flag() > 0);
 220:main.c        **** 		}
 221:main.c        **** 	//_delay_ms (150);
 222:main.c        **** 		string++;
 223:main.c        **** 		cnt++;
 224:main.c        **** 		
 225:main.c        **** 		
 226:main.c        **** 		}
 227:main.c        **** 	}
 228:main.c        **** 	
 229:main.c        **** 	
 230:main.c        **** 	
 231:main.c        **** void put_lcd_data(uint8_t data)	
 232:main.c        **** {
 183               		.loc 1 232 0
 184               		.cfi_startproc
 185               	.LVL10:
 186 00b2 0F93      		push r16
 187               	.LCFI6:
 188               		.cfi_def_cfa_offset 3
 189               		.cfi_offset 16, -2
 190 00b4 1F93      		push r17
 191               	.LCFI7:
 192               		.cfi_def_cfa_offset 4
 193               		.cfi_offset 17, -3
 194 00b6 CF93      		push r28
 195               	.LCFI8:
 196               		.cfi_def_cfa_offset 5
 197               		.cfi_offset 28, -4
 198 00b8 DF93      		push r29
 199               	.LCFI9:
 200               		.cfi_def_cfa_offset 6
 201               		.cfi_offset 29, -5
 202               	/* prologue: function */
 203               	/* frame size = 0 */
 204               	/* stack size = 4 */
 205               	.L__stack_usage = 4
 206 00ba C82F      		mov r28,r24
 233:main.c        **** 	LCD_DATA &= ~((1 << LCD_D7) | (1 << LCD_D6) | (1 << LCD_D5) | (1 << LCD_D4));
 207               		.loc 1 233 0
 208 00bc 8BB1      		in r24,0xb
 209               	.LVL11:
 210 00be 8F70      		andi r24,lo8(15)
 211 00c0 8BB9      		out 0xb,r24
 234:main.c        **** 	
 235:main.c        **** 	set_bits(&PORTB, 1, LCD_EN); 
 212               		.loc 1 235 0
 213 00c2 1F92      		push __zero_reg__
 214               	.LCFI10:
 215               		.cfi_def_cfa_offset 7
 216 00c4 84E0      		ldi r24,lo8(4)
 217 00c6 8F93      		push r24
 218               	.LCFI11:
 219               		.cfi_def_cfa_offset 8
 220 00c8 81E0      		ldi r24,lo8(1)
 221 00ca 8F93      		push r24
 222               	.LCFI12:
 223               		.cfi_def_cfa_offset 9
 224 00cc 1F92      		push __zero_reg__
 225               	.LCFI13:
 226               		.cfi_def_cfa_offset 10
 227 00ce 85E2      		ldi r24,lo8(37)
 228 00d0 8F93      		push r24
 229               	.LCFI14:
 230               		.cfi_def_cfa_offset 11
 231 00d2 0E94 0000 		call set_bits
 232               	.LVL12:
 236:main.c        **** 
 237:main.c        **** 	if ((data & BIT7) != 0)
 233               		.loc 1 237 0
 234 00d6 0F90      		pop __tmp_reg__
 235 00d8 0F90      		pop __tmp_reg__
 236 00da 0F90      		pop __tmp_reg__
 237 00dc 0F90      		pop __tmp_reg__
 238 00de 0F90      		pop __tmp_reg__
 239               	.LCFI15:
 240               		.cfi_def_cfa_offset 6
 241 00e0 C7FD      		sbrc r28,7
 238:main.c        **** 		LCD_DATA |= (1 << LCD_D7);
 242               		.loc 1 238 0
 243 00e2 5F9A      		sbi 0xb,7
 244               	.L11:
 239:main.c        **** 	if ((data & BIT6) != 0)
 245               		.loc 1 239 0
 246 00e4 C6FD      		sbrc r28,6
 240:main.c        **** 		LCD_DATA |= (1 << LCD_D6);
 247               		.loc 1 240 0
 248 00e6 5E9A      		sbi 0xb,6
 249               	.L12:
 241:main.c        **** 	if ((data & BIT5) != 0)
 250               		.loc 1 241 0
 251 00e8 C5FD      		sbrc r28,5
 242:main.c        **** 		LCD_DATA |= (1 << LCD_D5);
 252               		.loc 1 242 0
 253 00ea 5D9A      		sbi 0xb,5
 254               	.L13:
 243:main.c        **** 	if ((data & BIT4) != 0)
 255               		.loc 1 243 0
 256 00ec C4FD      		sbrc r28,4
 244:main.c        **** 		LCD_DATA |= (1 << LCD_D4);
 257               		.loc 1 244 0
 258 00ee 5C9A      		sbi 0xb,4
 259               	.L14:
 245:main.c        **** 
 246:main.c        **** 	clear_bits(&PORTB, 1, LCD_EN);
 260               		.loc 1 246 0
 261 00f0 1F92      		push __zero_reg__
 262               	.LCFI16:
 263               		.cfi_def_cfa_offset 7
 264 00f2 04E0      		ldi r16,lo8(4)
 265 00f4 0F93      		push r16
 266               	.LCFI17:
 267               		.cfi_def_cfa_offset 8
 268 00f6 11E0      		ldi r17,lo8(1)
 269 00f8 1F93      		push r17
 270               	.LCFI18:
 271               		.cfi_def_cfa_offset 9
 272 00fa 1F92      		push __zero_reg__
 273               	.LCFI19:
 274               		.cfi_def_cfa_offset 10
 275 00fc D5E2      		ldi r29,lo8(37)
 276 00fe DF93      		push r29
 277               	.LCFI20:
 278               		.cfi_def_cfa_offset 11
 279 0100 0E94 0000 		call clear_bits
 280               	.LVL13:
 247:main.c        **** 
 248:main.c        **** 	LCD_DATA &= ~((1 << LCD_D4) | (1 << LCD_D5) | (1 << LCD_D6) | (1 << LCD_D7));
 281               		.loc 1 248 0
 282 0104 8BB1      		in r24,0xb
 283 0106 8F70      		andi r24,lo8(15)
 284 0108 8BB9      		out 0xb,r24
 249:main.c        **** 
 250:main.c        **** 	set_bits(&PORTB, 1, LCD_EN);     
 285               		.loc 1 250 0
 286 010a 1F92      		push __zero_reg__
 287               	.LCFI21:
 288               		.cfi_def_cfa_offset 12
 289 010c 0F93      		push r16
 290               	.LCFI22:
 291               		.cfi_def_cfa_offset 13
 292 010e 1F93      		push r17
 293               	.LCFI23:
 294               		.cfi_def_cfa_offset 14
 295 0110 1F92      		push __zero_reg__
 296               	.LCFI24:
 297               		.cfi_def_cfa_offset 15
 298 0112 DF93      		push r29
 299               	.LCFI25:
 300               		.cfi_def_cfa_offset 16
 301 0114 0E94 0000 		call set_bits
 302               	.LVL14:
 251:main.c        **** 
 252:main.c        **** 	if ((data & BIT3) != 0)
 303               		.loc 1 252 0
 304 0118 8DB7      		in r24,__SP_L__
 305 011a 9EB7      		in r25,__SP_H__
 306 011c 0A96      		adiw r24,10
 307 011e 0FB6      		in __tmp_reg__,__SREG__
 308 0120 F894      		cli
 309 0122 9EBF      		out __SP_H__,r25
 310 0124 0FBE      		out __SREG__,__tmp_reg__
 311 0126 8DBF      		out __SP_L__,r24
 312               	.LCFI26:
 313               		.cfi_def_cfa_offset 6
 314 0128 C3FD      		sbrc r28,3
 253:main.c        **** 		LCD_DATA |= (1 << LCD_D7);
 315               		.loc 1 253 0
 316 012a 5F9A      		sbi 0xb,7
 317               	.L15:
 254:main.c        **** 	if ((data & BIT2) != 0)
 318               		.loc 1 254 0
 319 012c C2FD      		sbrc r28,2
 255:main.c        **** 		LCD_DATA |= (1 << LCD_D6);
 320               		.loc 1 255 0
 321 012e 5E9A      		sbi 0xb,6
 322               	.L16:
 256:main.c        **** 	if ((data & BIT1) != 0)
 323               		.loc 1 256 0
 324 0130 C1FD      		sbrc r28,1
 257:main.c        **** 		LCD_DATA |= (1 << LCD_D5);
 325               		.loc 1 257 0
 326 0132 5D9A      		sbi 0xb,5
 327               	.L17:
 258:main.c        **** 	if ((data & BIT0) != 0)
 328               		.loc 1 258 0
 329 0134 C0FD      		sbrc r28,0
 259:main.c        **** 		LCD_DATA |= (1 << LCD_D4);
 330               		.loc 1 259 0
 331 0136 5C9A      		sbi 0xb,4
 332               	.L18:
 260:main.c        **** 
 261:main.c        **** 	clear_bits(&PORTB, 1, LCD_EN);
 333               		.loc 1 261 0
 334 0138 1F92      		push __zero_reg__
 335               	.LCFI27:
 336               		.cfi_def_cfa_offset 7
 337 013a 84E0      		ldi r24,lo8(4)
 338 013c 8F93      		push r24
 339               	.LCFI28:
 340               		.cfi_def_cfa_offset 8
 341 013e 81E0      		ldi r24,lo8(1)
 342 0140 8F93      		push r24
 343               	.LCFI29:
 344               		.cfi_def_cfa_offset 9
 345 0142 1F92      		push __zero_reg__
 346               	.LCFI30:
 347               		.cfi_def_cfa_offset 10
 348 0144 85E2      		ldi r24,lo8(37)
 349 0146 8F93      		push r24
 350               	.LCFI31:
 351               		.cfi_def_cfa_offset 11
 352 0148 0E94 0000 		call clear_bits
 353               	.LVL15:
 262:main.c        **** 	
 263:main.c        **** 	
 264:main.c        **** 	
 265:main.c        **** 	
 266:main.c        **** 	while(get_lcd_busy_flag() > 0);  //Der ist wichtig!!!
 354               		.loc 1 266 0
 355 014c 0F90      		pop __tmp_reg__
 356 014e 0F90      		pop __tmp_reg__
 357 0150 0F90      		pop __tmp_reg__
 358 0152 0F90      		pop __tmp_reg__
 359 0154 0F90      		pop __tmp_reg__
 360               	.LCFI32:
 361               		.cfi_def_cfa_offset 6
 362               	.L19:
 363               		.loc 1 266 0 is_stmt 0 discriminator 1
 364 0156 0E94 0000 		call get_lcd_busy_flag
 365               	.LVL16:
 366 015a 1816      		cp __zero_reg__,r24
 367 015c 1906      		cpc __zero_reg__,r25
 368 015e 04F0      		brlt .L19
 369               	/* epilogue start */
 267:main.c        **** 	
 268:main.c        **** 	
 269:main.c        **** 		
 270:main.c        **** }
 370               		.loc 1 270 0 is_stmt 1
 371 0160 DF91      		pop r29
 372 0162 CF91      		pop r28
 373               	.LVL17:
 374 0164 1F91      		pop r17
 375 0166 0F91      		pop r16
 376 0168 0895      		ret
 377               		.cfi_endproc
 378               	.LFE16:
 380               	.global	lcd_write
 382               	lcd_write:
 383               	.LFB14:
 178:main.c        **** 		
 384               		.loc 1 178 0
 385               		.cfi_startproc
 386               	.LVL18:
 387 016a 0F93      		push r16
 388               	.LCFI33:
 389               		.cfi_def_cfa_offset 3
 390               		.cfi_offset 16, -2
 391 016c 1F93      		push r17
 392               	.LCFI34:
 393               		.cfi_def_cfa_offset 4
 394               		.cfi_offset 17, -3
 395 016e CF93      		push r28
 396               	.LCFI35:
 397               		.cfi_def_cfa_offset 5
 398               		.cfi_offset 28, -4
 399 0170 DF93      		push r29
 400               	.LCFI36:
 401               		.cfi_def_cfa_offset 6
 402               		.cfi_offset 29, -5
 403               	/* prologue: function */
 404               	/* frame size = 0 */
 405               	/* stack size = 4 */
 406               	.L__stack_usage = 4
 407 0172 082F      		mov r16,r24
 181:main.c        **** 	
 408               		.loc 1 181 0
 409 0174 1F92      		push __zero_reg__
 410               	.LCFI37:
 411               		.cfi_def_cfa_offset 7
 412 0176 12E0      		ldi r17,lo8(2)
 413 0178 1F93      		push r17
 414               	.LCFI38:
 415               		.cfi_def_cfa_offset 8
 416 017a D1E0      		ldi r29,lo8(1)
 417 017c DF93      		push r29
 418               	.LCFI39:
 419               		.cfi_def_cfa_offset 9
 420 017e 1F92      		push __zero_reg__
 421               	.LCFI40:
 422               		.cfi_def_cfa_offset 10
 423 0180 CBE2      		ldi r28,lo8(43)
 424 0182 CF93      		push r28
 425               	.LCFI41:
 426               		.cfi_def_cfa_offset 11
 427 0184 0E94 0000 		call set_bits
 428               	.LVL19:
 429               	.LBB39:
 430               	.LBB40:
 431               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 432               		.loc 2 187 0
 433 0188 8FE9      		ldi r24,lo8(3999)
 434 018a 9FE0      		ldi r25,hi8(3999)
 435 018c 0197      	1:	sbiw r24,1
 436 018e 01F4      		brne 1b
 437 0190 00C0      		rjmp .
 438 0192 0000      		nop
 439               	.LVL20:
 440               	.LBE40:
 441               	.LBE39:
 185:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 442               		.loc 1 185 0
 443 0194 802F      		mov r24,r16
 444 0196 90E0      		ldi r25,0
 445 0198 0E94 0000 		call put_lcd_data
 446               	.LVL21:
 192:main.c        **** 	
 447               		.loc 1 192 0
 448 019c 1F92      		push __zero_reg__
 449               	.LCFI42:
 450               		.cfi_def_cfa_offset 12
 451 019e 1F93      		push r17
 452               	.LCFI43:
 453               		.cfi_def_cfa_offset 13
 454 01a0 DF93      		push r29
 455               	.LCFI44:
 456               		.cfi_def_cfa_offset 14
 457 01a2 1F92      		push __zero_reg__
 458               	.LCFI45:
 459               		.cfi_def_cfa_offset 15
 460 01a4 CF93      		push r28
 461               	.LCFI46:
 462               		.cfi_def_cfa_offset 16
 463 01a6 0E94 0000 		call clear_bits
 464               	.LVL22:
 196:main.c        **** 	
 465               		.loc 1 196 0
 466 01aa 8DB7      		in r24,__SP_L__
 467 01ac 9EB7      		in r25,__SP_H__
 468 01ae 0A96      		adiw r24,10
 469 01b0 0FB6      		in __tmp_reg__,__SREG__
 470 01b2 F894      		cli
 471 01b4 9EBF      		out __SP_H__,r25
 472 01b6 0FBE      		out __SREG__,__tmp_reg__
 473 01b8 8DBF      		out __SP_L__,r24
 474               	.LCFI47:
 475               		.cfi_def_cfa_offset 6
 476               	/* epilogue start */
 477 01ba DF91      		pop r29
 478 01bc CF91      		pop r28
 479 01be 1F91      		pop r17
 480 01c0 0F91      		pop r16
 481               	.LVL23:
 482 01c2 0895      		ret
 483               		.cfi_endproc
 484               	.LFE14:
 486               	.global	lcd_write_string
 488               	lcd_write_string:
 489               	.LFB15:
 200:main.c        **** 	int cnt = 0; 
 490               		.loc 1 200 0
 491               		.cfi_startproc
 492 01c4 AF92      		push r10
 493               	.LCFI48:
 494               		.cfi_def_cfa_offset 3
 495               		.cfi_offset 10, -2
 496 01c6 BF92      		push r11
 497               	.LCFI49:
 498               		.cfi_def_cfa_offset 4
 499               		.cfi_offset 11, -3
 500 01c8 DF92      		push r13
 501               	.LCFI50:
 502               		.cfi_def_cfa_offset 5
 503               		.cfi_offset 13, -4
 504 01ca EF92      		push r14
 505               	.LCFI51:
 506               		.cfi_def_cfa_offset 6
 507               		.cfi_offset 14, -5
 508 01cc FF92      		push r15
 509               	.LCFI52:
 510               		.cfi_def_cfa_offset 7
 511               		.cfi_offset 15, -6
 512 01ce 0F93      		push r16
 513               	.LCFI53:
 514               		.cfi_def_cfa_offset 8
 515               		.cfi_offset 16, -7
 516 01d0 1F93      		push r17
 517               	.LCFI54:
 518               		.cfi_def_cfa_offset 9
 519               		.cfi_offset 17, -8
 520 01d2 CF93      		push r28
 521               	.LCFI55:
 522               		.cfi_def_cfa_offset 10
 523               		.cfi_offset 28, -9
 524 01d4 DF93      		push r29
 525               	.LCFI56:
 526               		.cfi_def_cfa_offset 11
 527               		.cfi_offset 29, -10
 528               	/* prologue: function */
 529               	/* frame size = 0 */
 530               	/* stack size = 9 */
 531               	.L__stack_usage = 9
 532 01d6 EC01      		movw r28,r24
 201:main.c        **** 	
 533               		.loc 1 201 0
 534 01d8 00E0      		ldi r16,0
 535 01da 10E0      		ldi r17,0
 536               	.LBB41:
 205:main.c        **** 		
 537               		.loc 1 205 0
 538 01dc 82E0      		ldi r24,lo8(2)
 539 01de F82E      		mov r15,r24
 540 01e0 EE24      		clr r14
 541 01e2 E394      		inc r14
 542 01e4 9BE2      		ldi r25,lo8(43)
 543 01e6 D92E      		mov r13,r25
 544               	.L44:
 545 01e8 5E01      		movw r10,r28
 546               	.LBE41:
 203:main.c        **** 			
 547               		.loc 1 203 0
 548 01ea 8881      		ld r24,Y
 549 01ec 8823      		tst r24
 550 01ee 01F0      		breq .L47
 551               	.LBB44:
 205:main.c        **** 		
 552               		.loc 1 205 0
 553 01f0 1F92      		push __zero_reg__
 554               	.LCFI57:
 555               		.cfi_def_cfa_offset 12
 556 01f2 FF92      		push r15
 557               	.LCFI58:
 558               		.cfi_def_cfa_offset 13
 559 01f4 EF92      		push r14
 560               	.LCFI59:
 561               		.cfi_def_cfa_offset 14
 562 01f6 1F92      		push __zero_reg__
 563               	.LCFI60:
 564               		.cfi_def_cfa_offset 15
 565 01f8 DF92      		push r13
 566               	.LCFI61:
 567               		.cfi_def_cfa_offset 16
 568 01fa 0E94 0000 		call set_bits
 569               	.LBB42:
 570               	.LBB43:
 571               		.loc 2 187 0
 572 01fe 8FE9      		ldi r24,lo8(3999)
 573 0200 9FE0      		ldi r25,hi8(3999)
 574 0202 0197      	1:	sbiw r24,1
 575 0204 01F4      		brne 1b
 576 0206 00C0      		rjmp .
 577 0208 0000      		nop
 578 020a 2196      		adiw r28,1
 579               	.LBE43:
 580               	.LBE42:
 209:main.c        **** 		//while(get_lcd_busy_flag() > 0);	
 581               		.loc 1 209 0
 582 020c F501      		movw r30,r10
 583 020e 8081      		ld r24,Z
 584 0210 90E0      		ldi r25,0
 585 0212 0E94 0000 		call put_lcd_data
 212:main.c        **** 			
 586               		.loc 1 212 0
 587 0216 1F92      		push __zero_reg__
 588               	.LCFI62:
 589               		.cfi_def_cfa_offset 17
 590 0218 FF92      		push r15
 591               	.LCFI63:
 592               		.cfi_def_cfa_offset 18
 593 021a EF92      		push r14
 594               	.LCFI64:
 595               		.cfi_def_cfa_offset 19
 596 021c 1F92      		push __zero_reg__
 597               	.LCFI65:
 598               		.cfi_def_cfa_offset 20
 599 021e DF92      		push r13
 600               	.LCFI66:
 601               		.cfi_def_cfa_offset 21
 602 0220 0E94 0000 		call clear_bits
 214:main.c        **** 		{
 603               		.loc 1 214 0
 604 0224 8DB7      		in r24,__SP_L__
 605 0226 9EB7      		in r25,__SP_H__
 606 0228 0A96      		adiw r24,10
 607 022a 0FB6      		in __tmp_reg__,__SREG__
 608 022c F894      		cli
 609 022e 9EBF      		out __SP_H__,r25
 610 0230 0FBE      		out __SREG__,__tmp_reg__
 611 0232 8DBF      		out __SP_L__,r24
 612               	.LCFI67:
 613               		.cfi_def_cfa_offset 11
 614 0234 0F30      		cpi r16,15
 615 0236 1105      		cpc r17,__zero_reg__
 616 0238 01F4      		brne .L45
 218:main.c        **** 		//while(get_lcd_busy_flag() > 0);
 617               		.loc 1 218 0
 618 023a 80EC      		ldi r24,lo8(-64)
 619 023c 90E0      		ldi r25,0
 620 023e 0E94 0000 		call put_lcd_data
 621               	.L45:
 223:main.c        **** 		
 622               		.loc 1 223 0
 623 0242 0F5F      		subi r16,-1
 624 0244 1F4F      		sbci r17,-1
 625 0246 00C0      		rjmp .L44
 626               	.L47:
 627               	/* epilogue start */
 628               	.LBE44:
 227:main.c        **** 	
 629               		.loc 1 227 0
 630 0248 DF91      		pop r29
 631 024a CF91      		pop r28
 632 024c 1F91      		pop r17
 633 024e 0F91      		pop r16
 634 0250 FF90      		pop r15
 635 0252 EF90      		pop r14
 636 0254 DF90      		pop r13
 637 0256 BF90      		pop r11
 638 0258 AF90      		pop r10
 639 025a 0895      		ret
 640               		.cfi_endproc
 641               	.LFE15:
 643               	.global	put_lcd_nibble
 645               	put_lcd_nibble:
 646               	.LFB17:
 271:main.c        **** 
 272:main.c        **** void put_lcd_nibble(uint8_t data)	
 273:main.c        **** {
 647               		.loc 1 273 0
 648               		.cfi_startproc
 649               	.LVL24:
 650 025c CF93      		push r28
 651               	.LCFI68:
 652               		.cfi_def_cfa_offset 3
 653               		.cfi_offset 28, -2
 654               	/* prologue: function */
 655               	/* frame size = 0 */
 656               	/* stack size = 1 */
 657               	.L__stack_usage = 1
 658 025e C82F      		mov r28,r24
 274:main.c        **** 	set_bits(&PORTB, 1, LCD_EN); 
 659               		.loc 1 274 0
 660 0260 1F92      		push __zero_reg__
 661               	.LCFI69:
 662               		.cfi_def_cfa_offset 4
 663 0262 84E0      		ldi r24,lo8(4)
 664               	.LVL25:
 665 0264 8F93      		push r24
 666               	.LCFI70:
 667               		.cfi_def_cfa_offset 5
 668 0266 81E0      		ldi r24,lo8(1)
 669 0268 8F93      		push r24
 670               	.LCFI71:
 671               		.cfi_def_cfa_offset 6
 672 026a 1F92      		push __zero_reg__
 673               	.LCFI72:
 674               		.cfi_def_cfa_offset 7
 675 026c 85E2      		ldi r24,lo8(37)
 676 026e 8F93      		push r24
 677               	.LCFI73:
 678               		.cfi_def_cfa_offset 8
 679 0270 0E94 0000 		call set_bits
 680               	.LVL26:
 681               	.LBB45:
 682               	.LBB46:
 683               		.loc 2 187 0
 684 0274 2FEF      		ldi r18,lo8(319999)
 685 0276 81EE      		ldi r24,hi8(319999)
 686 0278 94E0      		ldi r25,hlo8(319999)
 687 027a 2150      	1:	subi r18,1
 688 027c 8040      		sbci r24,0
 689 027e 9040      		sbci r25,0
 690 0280 01F4      		brne 1b
 691 0282 00C0      		rjmp .
 692 0284 0000      		nop
 693               	.LVL27:
 694               	.LBE46:
 695               	.LBE45:
 275:main.c        ****    _delay_ms (100);
 276:main.c        **** 	LCD_DATA &= ~((1 << LCD_D7) | (1 << LCD_D6) | (1 << LCD_D5) | (1 << LCD_D4));
 696               		.loc 1 276 0
 697 0286 8BB1      		in r24,0xb
 698 0288 8F70      		andi r24,lo8(15)
 699 028a 8BB9      		out 0xb,r24
 277:main.c        **** 	
 278:main.c        **** 	if ((data & BIT3) != 0)
 700               		.loc 1 278 0
 701 028c 0F90      		pop __tmp_reg__
 702 028e 0F90      		pop __tmp_reg__
 703 0290 0F90      		pop __tmp_reg__
 704 0292 0F90      		pop __tmp_reg__
 705 0294 0F90      		pop __tmp_reg__
 706               	.LCFI74:
 707               		.cfi_def_cfa_offset 3
 708 0296 C3FD      		sbrc r28,3
 279:main.c        **** 		LCD_DATA |= (1 << LCD_D7);
 709               		.loc 1 279 0
 710 0298 5F9A      		sbi 0xb,7
 711               	.L49:
 280:main.c        **** 	if ((data & BIT2) != 0)
 712               		.loc 1 280 0
 713 029a C2FD      		sbrc r28,2
 281:main.c        **** 		LCD_DATA |= (1 << LCD_D6);
 714               		.loc 1 281 0
 715 029c 5E9A      		sbi 0xb,6
 716               	.L50:
 282:main.c        **** 	if ((data & BIT1) != 0)
 717               		.loc 1 282 0
 718 029e C1FD      		sbrc r28,1
 283:main.c        **** 		LCD_DATA |= (1 << LCD_D5);
 719               		.loc 1 283 0
 720 02a0 5D9A      		sbi 0xb,5
 721               	.L51:
 284:main.c        **** 	if ((data & BIT0) != 0)
 722               		.loc 1 284 0
 723 02a2 C0FD      		sbrc r28,0
 285:main.c        **** 		LCD_DATA |= (1 << LCD_D4);
 724               		.loc 1 285 0
 725 02a4 5C9A      		sbi 0xb,4
 726               	.L52:
 727               	.LVL28:
 728               	.LBB47:
 729               	.LBB48:
 730               		.loc 2 187 0
 731 02a6 2FEF      		ldi r18,lo8(319999)
 732 02a8 81EE      		ldi r24,hi8(319999)
 733 02aa 94E0      		ldi r25,hlo8(319999)
 734 02ac 2150      	1:	subi r18,1
 735 02ae 8040      		sbci r24,0
 736 02b0 9040      		sbci r25,0
 737 02b2 01F4      		brne 1b
 738 02b4 00C0      		rjmp .
 739 02b6 0000      		nop
 740               	.LVL29:
 741               	.LBE48:
 742               	.LBE47:
 286:main.c        **** 	_delay_ms (100);
 287:main.c        **** 	clear_bits(&PORTB, 1, LCD_EN);
 743               		.loc 1 287 0
 744 02b8 1F92      		push __zero_reg__
 745               	.LCFI75:
 746               		.cfi_def_cfa_offset 4
 747 02ba 84E0      		ldi r24,lo8(4)
 748 02bc 8F93      		push r24
 749               	.LCFI76:
 750               		.cfi_def_cfa_offset 5
 751 02be 81E0      		ldi r24,lo8(1)
 752 02c0 8F93      		push r24
 753               	.LCFI77:
 754               		.cfi_def_cfa_offset 6
 755 02c2 1F92      		push __zero_reg__
 756               	.LCFI78:
 757               		.cfi_def_cfa_offset 7
 758 02c4 85E2      		ldi r24,lo8(37)
 759 02c6 8F93      		push r24
 760               	.LCFI79:
 761               		.cfi_def_cfa_offset 8
 762 02c8 0E94 0000 		call clear_bits
 763               	.LVL30:
 288:main.c        **** }	
 764               		.loc 1 288 0
 765 02cc 0F90      		pop __tmp_reg__
 766 02ce 0F90      		pop __tmp_reg__
 767 02d0 0F90      		pop __tmp_reg__
 768 02d2 0F90      		pop __tmp_reg__
 769 02d4 0F90      		pop __tmp_reg__
 770               	.LCFI80:
 771               		.cfi_def_cfa_offset 3
 772               	/* epilogue start */
 773 02d6 CF91      		pop r28
 774               	.LVL31:
 775 02d8 0895      		ret
 776               		.cfi_endproc
 777               	.LFE17:
 779               	.global	debug_pin
 781               	debug_pin:
 782               	.LFB18:
 289:main.c        **** 
 290:main.c        **** 
 291:main.c        **** 
 292:main.c        **** void   debug_pin(uint8_t bit)                                                                      
 293:main.c        **** {
 783               		.loc 1 293 0
 784               		.cfi_startproc
 785               	.LVL32:
 786               	/* prologue: function */
 787               	/* frame size = 0 */
 788               	/* stack size = 0 */
 789               	.L__stack_usage = 0
 294:main.c        **** 		PORTB |= (1 << bit);
 790               		.loc 1 294 0
 791 02da 45B1      		in r20,0x5
 792 02dc 21E0      		ldi r18,lo8(1)
 793 02de 30E0      		ldi r19,0
 794 02e0 B901      		movw r22,r18
 795 02e2 00C0      		rjmp 2f
 796               		1:
 797 02e4 660F      		lsl r22
 798 02e6 771F      		rol r23
 799               		2:
 800 02e8 8A95      		dec r24
 801 02ea 02F4      		brpl 1b
 802 02ec CB01      		movw r24,r22
 803               	.LVL33:
 804 02ee 462B      		or r20,r22
 805 02f0 45B9      		out 0x5,r20
 806               	.LVL34:
 807               	.LBB49:
 808               	.LBB50:
 809               		.loc 2 187 0
 810 02f2 7FEF      		ldi r23,lo8(3199999)
 811 02f4 23ED      		ldi r18,hi8(3199999)
 812 02f6 30E3      		ldi r19,hlo8(3199999)
 813 02f8 7150      	1:	subi r23,1
 814 02fa 2040      		sbci r18,0
 815 02fc 3040      		sbci r19,0
 816 02fe 01F4      		brne 1b
 817 0300 00C0      		rjmp .
 818 0302 0000      		nop
 819               	.LVL35:
 820               	.LBE50:
 821               	.LBE49:
 295:main.c        **** 		_delay_ms (1000);
 296:main.c        **** 		PORTB &= ~(1 << bit);
 822               		.loc 1 296 0
 823 0304 95B1      		in r25,0x5
 824 0306 8095      		com r24
 825 0308 8923      		and r24,r25
 826 030a 85B9      		out 0x5,r24
 827               	.LVL36:
 828               	.LBB51:
 829               	.LBB52:
 830               		.loc 2 187 0
 831 030c 4FEF      		ldi r20,lo8(3199999)
 832 030e 63ED      		ldi r22,hi8(3199999)
 833 0310 70E3      		ldi r23,hlo8(3199999)
 834 0312 4150      	1:	subi r20,1
 835 0314 6040      		sbci r22,0
 836 0316 7040      		sbci r23,0
 837 0318 01F4      		brne 1b
 838 031a 00C0      		rjmp .
 839 031c 0000      		nop
 840               	.LVL37:
 841 031e 0895      		ret
 842               	.LBE52:
 843               	.LBE51:
 844               		.cfi_endproc
 845               	.LFE18:
 847               		.section	.rodata.str1.1,"aMS",@progbits,1
 848               	.LC0:
 849 0000 4E61 2064 		.string	"Na das war aber eine schwere Geburt"
 849      6173 2077 
 849      6172 2061 
 849      6265 7220 
 849      6569 6E65 
 850               	.LC1:
 851 0024 556E 6420 		.string	"Und das alles wegen einem schlechten Datenblatt..."
 851      6461 7320 
 851      616C 6C65 
 851      7320 7765 
 851      6765 6E20 
 852               	.LC2:
 853 0057 444D 5347 		.string	"DMSG: PORTB:%x"
 853      3A20 504F 
 853      5254 423A 
 853      2578 00
 854               	.LC3:
 855 0066 5345 4E53 		.string	"SENSOR: %x"
 855      4F52 3A20 
 855      2578 00
 856               		.section	.text.startup,"ax",@progbits
 857               	.global	main
 859               	main:
 860               	.LFB11:
  38:main.c        **** 	
 861               		.loc 1 38 0
 862               		.cfi_startproc
 863 0000 CF93      		push r28
 864               	.LCFI81:
 865               		.cfi_def_cfa_offset 3
 866               		.cfi_offset 28, -2
 867 0002 DF93      		push r29
 868               	.LCFI82:
 869               		.cfi_def_cfa_offset 4
 870               		.cfi_offset 29, -3
 871 0004 CDB7      		in r28,__SP_L__
 872 0006 DEB7      		in r29,__SP_H__
 873               	.LCFI83:
 874               		.cfi_def_cfa_register 28
 875 0008 A897      		sbiw r28,40
 876               	.LCFI84:
 877               		.cfi_def_cfa_offset 44
 878 000a 0FB6      		in __tmp_reg__,__SREG__
 879 000c F894      		cli
 880 000e DEBF      		out __SP_H__,r29
 881 0010 0FBE      		out __SREG__,__tmp_reg__
 882 0012 CDBF      		out __SP_L__,r28
 883               	/* prologue: function */
 884               	/* frame size = 40 */
 885               	/* stack size = 42 */
 886               	.L__stack_usage = 42
 887               	.LVL38:
 888               	.LBB53:
 889               	.LBB54:
 890               		.loc 2 187 0
 891 0014 2FEF      		ldi r18,lo8(63999)
 892 0016 89EF      		ldi r24,hi8(63999)
 893 0018 90E0      		ldi r25,hlo8(63999)
 894 001a 2150      	1:	subi r18,1
 895 001c 8040      		sbci r24,0
 896 001e 9040      		sbci r25,0
 897 0020 01F4      		brne 1b
 898 0022 00C0      		rjmp .
 899 0024 0000      		nop
 900               	.LVL39:
 901               	.LBE54:
 902               	.LBE53:
  41:main.c        ****             
 903               		.loc 1 41 0
 904 0026 8FEF      		ldi r24,lo8(-1)
 905 0028 84B9      		out 0x4,r24
  43:main.c        **** 
 906               		.loc 1 43 0
 907 002a 8AB9      		out 0xa,r24
  47:main.c        ****    _delay_ms (10); 
 908               		.loc 1 47 0
 909 002c 23E0      		ldi r18,lo8(3)
 910 002e 30E0      		ldi r19,0
 911 0030 42E0      		ldi r20,lo8(2)
 912 0032 50E0      		ldi r21,0
 913 0034 62E0      		ldi r22,lo8(2)
 914 0036 70E0      		ldi r23,0
 915 0038 8BE2      		ldi r24,lo8(43)
 916 003a 90E0      		ldi r25,0
 917 003c 0E94 0000 		call clear_bits
 918               	.LVL40:
 919               	.LBB55:
 920               	.LBB56:
 921               		.loc 2 187 0
 922 0040 8FE3      		ldi r24,lo8(-25537)
 923 0042 9CE9      		ldi r25,hi8(-25537)
 924 0044 0197      	1:	sbiw r24,1
 925 0046 01F4      		brne 1b
 926 0048 00C0      		rjmp .
 927 004a 0000      		nop
 928               	.LVL41:
 929               	.LBE56:
 930               	.LBE55:
  50:main.c        **** _delay_ms (4.1);
 931               		.loc 1 50 0
 932 004c 83E0      		ldi r24,lo8(3)
 933 004e 90E0      		ldi r25,0
 934 0050 0E94 0000 		call put_lcd_nibble
 935               	.LVL42:
 936               	.LBB57:
 937               	.LBB58:
 938               		.loc 2 187 0
 939 0054 8FE0      		ldi r24,lo8(16399)
 940 0056 90E4      		ldi r25,hi8(16399)
 941 0058 0197      	1:	sbiw r24,1
 942 005a 01F4      		brne 1b
 943 005c 00C0      		rjmp .
 944 005e 0000      		nop
 945               	.LVL43:
 946               	.LBE58:
 947               	.LBE57:
  53:main.c        **** _delay_us (100);
 948               		.loc 1 53 0
 949 0060 83E0      		ldi r24,lo8(3)
 950 0062 90E0      		ldi r25,0
 951 0064 0E94 0000 		call put_lcd_nibble
 952               	.LVL44:
 953               	.LBB59:
 954               	.LBB60:
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 955               		.loc 2 276 0
 956 0068 8FE8      		ldi r24,lo8(399)
 957 006a 91E0      		ldi r25,hi8(399)
 958 006c 0197      	1:	sbiw r24,1
 959 006e 01F4      		brne 1b
 960 0070 00C0      		rjmp .
 961 0072 0000      		nop
 962               	.LVL45:
 963               	.LBE60:
 964               	.LBE59:
  60:main.c        **** _delay_ms (4.1);
 965               		.loc 1 60 0
 966 0074 83E0      		ldi r24,lo8(3)
 967 0076 90E0      		ldi r25,0
 968 0078 0E94 0000 		call put_lcd_nibble
 969               	.LVL46:
 970               	.LBB61:
 971               	.LBB62:
 187:/usr/lib/avr/include/util/delay.h **** 
 972               		.loc 2 187 0
 973 007c 8FE0      		ldi r24,lo8(16399)
 974 007e 90E4      		ldi r25,hi8(16399)
 975 0080 0197      	1:	sbiw r24,1
 976 0082 01F4      		brne 1b
 977 0084 00C0      		rjmp .
 978 0086 0000      		nop
 979               	.LVL47:
 980               	.LBE62:
 981               	.LBE61:
  62:main.c        **** _delay_ms (4.1);
 982               		.loc 1 62 0
 983 0088 82E0      		ldi r24,lo8(2)
 984 008a 90E0      		ldi r25,0
 985 008c 0E94 0000 		call put_lcd_nibble
 986               	.LVL48:
 987               	.LBB63:
 988               	.LBB64:
 187:/usr/lib/avr/include/util/delay.h **** 
 989               		.loc 2 187 0
 990 0090 8FE0      		ldi r24,lo8(16399)
 991 0092 90E4      		ldi r25,hi8(16399)
 992 0094 0197      	1:	sbiw r24,1
 993 0096 01F4      		brne 1b
 994 0098 00C0      		rjmp .
 995 009a 0000      		nop
 996               	.LVL49:
 997               	.LBE64:
 998               	.LBE63:
  65:main.c        **** 
 999               		.loc 1 65 0
 1000 009c 88E2      		ldi r24,lo8(40)
 1001 009e 90E0      		ldi r25,0
 1002 00a0 0E94 0000 		call put_lcd_data
 1003               	.LVL50:
  67:main.c        **** 
 1004               		.loc 1 67 0
 1005 00a4 88E0      		ldi r24,lo8(8)
 1006 00a6 90E0      		ldi r25,0
 1007 00a8 0E94 0000 		call put_lcd_data
 1008               	.LVL51:
  69:main.c        **** 
 1009               		.loc 1 69 0
 1010 00ac 81E0      		ldi r24,lo8(1)
 1011 00ae 90E0      		ldi r25,0
 1012 00b0 0E94 0000 		call put_lcd_data
 1013               	.LVL52:
  73:main.c        **** 
 1014               		.loc 1 73 0
 1015 00b4 86E0      		ldi r24,lo8(6)
 1016 00b6 90E0      		ldi r25,0
 1017 00b8 0E94 0000 		call put_lcd_data
 1018               	.LVL53:
  76:main.c        **** 
 1019               		.loc 1 76 0
 1020 00bc 8FE0      		ldi r24,lo8(15)
 1021 00be 90E0      		ldi r25,0
 1022 00c0 0E94 0000 		call put_lcd_data
 1023               	.LVL54:
  86:main.c        ****    	 _delay_ms (2000);
 1024               		.loc 1 86 0
 1025 00c4 80E0      		ldi r24,lo8(.LC0)
 1026 00c6 90E0      		ldi r25,hi8(.LC0)
 1027 00c8 0E94 0000 		call lcd_write_string
 1028               	.LVL55:
 1029               	.LBB65:
 1030               	.LBB66:
 187:/usr/lib/avr/include/util/delay.h **** 
 1031               		.loc 2 187 0
 1032 00cc 9FEF      		ldi r25,lo8(6399999)
 1033 00ce 27EA      		ldi r18,hi8(6399999)
 1034 00d0 81E6      		ldi r24,hlo8(6399999)
 1035 00d2 9150      	1:	subi r25,1
 1036 00d4 2040      		sbci r18,0
 1037 00d6 8040      		sbci r24,0
 1038 00d8 01F4      		brne 1b
 1039 00da 00C0      		rjmp .
 1040 00dc 0000      		nop
 1041               	.LVL56:
 1042               	.LBE66:
 1043               	.LBE65:
  89:main.c        ****   
 1044               		.loc 1 89 0
 1045 00de 81E0      		ldi r24,lo8(1)
 1046 00e0 90E0      		ldi r25,0
 1047 00e2 0E94 0000 		call put_lcd_data
 1048               	.LVL57:
  92:main.c        **** 	_delay_ms (2000);
 1049               		.loc 1 92 0
 1050 00e6 80E0      		ldi r24,lo8(.LC1)
 1051 00e8 90E0      		ldi r25,hi8(.LC1)
 1052 00ea 0E94 0000 		call lcd_write_string
 1053               	.LVL58:
 1054               	.LBB67:
 1055               	.LBB68:
 187:/usr/lib/avr/include/util/delay.h **** 
 1056               		.loc 2 187 0
 1057 00ee 9FEF      		ldi r25,lo8(6399999)
 1058 00f0 27EA      		ldi r18,hi8(6399999)
 1059 00f2 81E6      		ldi r24,hlo8(6399999)
 1060 00f4 9150      	1:	subi r25,1
 1061 00f6 2040      		sbci r18,0
 1062 00f8 8040      		sbci r24,0
 1063 00fa 01F4      		brne 1b
 1064 00fc 00C0      		rjmp .
 1065 00fe 0000      		nop
 1066               	.LVL59:
 1067               	.LBE68:
 1068               	.LBE67:
  94:main.c        **** 	
 1069               		.loc 1 94 0
 1070 0100 81E0      		ldi r24,lo8(1)
 1071 0102 90E0      		ldi r25,0
 1072 0104 0E94 0000 		call put_lcd_data
 1073               	.LVL60:
  97:main.c        **** 	lcd_write_string(formatted_string);
 1074               		.loc 1 97 0
 1075 0108 85B1      		in r24,0x5
 1076 010a 1F92      		push __zero_reg__
 1077 010c 8F93      		push r24
 1078 010e 80E0      		ldi r24,lo8(.LC2)
 1079 0110 90E0      		ldi r25,hi8(.LC2)
 1080 0112 9F93      		push r25
 1081 0114 8F93      		push r24
 1082 0116 8E01      		movw r16,r28
 1083 0118 0F5F      		subi r16,-1
 1084 011a 1F4F      		sbci r17,-1
 1085 011c 1F93      		push r17
 1086 011e 0F93      		push r16
 1087 0120 0E94 0000 		call sprintf
 1088               	.LVL61:
  98:main.c        **** 	_delay_ms (2000);
 1089               		.loc 1 98 0
 1090 0124 C801      		movw r24,r16
 1091 0126 0E94 0000 		call lcd_write_string
 1092               	.LVL62:
 1093               	.LBB69:
 1094               	.LBB70:
 187:/usr/lib/avr/include/util/delay.h **** 
 1095               		.loc 2 187 0
 1096 012a 9FEF      		ldi r25,lo8(6399999)
 1097 012c 27EA      		ldi r18,hi8(6399999)
 1098 012e 81E6      		ldi r24,hlo8(6399999)
 1099 0130 9150      	1:	subi r25,1
 1100 0132 2040      		sbci r18,0
 1101 0134 8040      		sbci r24,0
 1102 0136 01F4      		brne 1b
 1103 0138 00C0      		rjmp .
 1104 013a 0000      		nop
 1105               	.LVL63:
 1106               	.LBE70:
 1107               	.LBE69:
 102:main.c        **** 	_delay_ms (20);
 1108               		.loc 1 102 0
 1109 013c 2298      		cbi 0x4,2
 1110               	.LVL64:
 1111               	.LBB71:
 1112               	.LBB72:
 187:/usr/lib/avr/include/util/delay.h **** 
 1113               		.loc 2 187 0
 1114 013e 9FEF      		ldi r25,lo8(63999)
 1115 0140 29EF      		ldi r18,hi8(63999)
 1116 0142 80E0      		ldi r24,hlo8(63999)
 1117 0144 9150      	1:	subi r25,1
 1118 0146 2040      		sbci r18,0
 1119 0148 8040      		sbci r24,0
 1120 014a 01F4      		brne 1b
 1121 014c 00C0      		rjmp .
 1122 014e 0000      		nop
 1123               	.LVL65:
 1124               	.LBE72:
 1125               	.LBE71:
 106:main.c        **** 		
 1126               		.loc 1 106 0
 1127 0150 81E0      		ldi r24,lo8(1)
 1128 0152 90E0      		ldi r25,0
 1129 0154 0E94 0000 		call put_lcd_data
 1130               	.LVL66:
 1131 0158 0F90      		pop __tmp_reg__
 1132 015a 0F90      		pop __tmp_reg__
 1133 015c 0F90      		pop __tmp_reg__
 1134 015e 0F90      		pop __tmp_reg__
 1135 0160 0F90      		pop __tmp_reg__
 1136 0162 0F90      		pop __tmp_reg__
 1137               	.LBB73:
 113:main.c        **** 	lcd_write_string(formatted_string);
 1138               		.loc 1 113 0
 1139 0164 80E0      		ldi r24,lo8(.LC3)
 1140 0166 E82E      		mov r14,r24
 1141 0168 80E0      		ldi r24,hi8(.LC3)
 1142 016a F82E      		mov r15,r24
 1143               	.L67:
 111:main.c        ****         
 1144               		.loc 1 111 0 discriminator 1
 1145 016c 80E0      		ldi r24,0
 1146 016e 90E0      		ldi r25,0
 1147 0170 0E94 0000 		call debug_pin
 1148               	.LVL67:
 113:main.c        **** 	lcd_write_string(formatted_string);
 1149               		.loc 1 113 0 discriminator 1
 1150 0174 83B1      		in r24,0x3
 1151 0176 8470      		andi r24,lo8(4)
 1152 0178 1F92      		push __zero_reg__
 1153 017a 8F93      		push r24
 1154 017c FF92      		push r15
 1155 017e EF92      		push r14
 1156 0180 1F93      		push r17
 1157 0182 0F93      		push r16
 1158 0184 0E94 0000 		call sprintf
 1159               	.LVL68:
 114:main.c        **** 	
 1160               		.loc 1 114 0 discriminator 1
 1161 0188 C801      		movw r24,r16
 1162 018a 0E94 0000 		call lcd_write_string
 1163               	.LVL69:
 116:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 1164               		.loc 1 116 0 discriminator 1
 1165 018e 80EC      		ldi r24,lo8(-64)
 1166 0190 90E0      		ldi r25,0
 1167 0192 0E94 0000 		call put_lcd_data
 1168               	.LVL70:
 1169               	.LBB74:
 1170               	.LBB75:
 187:/usr/lib/avr/include/util/delay.h **** 
 1171               		.loc 2 187 0 discriminator 1
 1172 0196 9FEF      		ldi r25,lo8(3199999)
 1173 0198 23ED      		ldi r18,hi8(3199999)
 1174 019a 80E3      		ldi r24,hlo8(3199999)
 1175 019c 9150      	1:	subi r25,1
 1176 019e 2040      		sbci r18,0
 1177 01a0 8040      		sbci r24,0
 1178 01a2 01F4      		brne 1b
 1179 01a4 00C0      		rjmp .
 1180 01a6 0000      		nop
 1181 01a8 0F90      		pop __tmp_reg__
 1182 01aa 0F90      		pop __tmp_reg__
 1183 01ac 0F90      		pop __tmp_reg__
 1184 01ae 0F90      		pop __tmp_reg__
 1185 01b0 0F90      		pop __tmp_reg__
 1186 01b2 0F90      		pop __tmp_reg__
 1187 01b4 00C0      		rjmp .L67
 1188               	.LBE75:
 1189               	.LBE74:
 1190               	.LBE73:
 1191               		.cfi_endproc
 1192               	.LFE11:
 1194               		.text
 1195               	.Letext0:
 1196               		.file 3 "/usr/lib/avr/include/stdint.h"
 1197               		.file 4 "/usr/lib/gcc/avr/5.4.0/include/stdarg.h"
 1198               		.file 5 "lcd_1602A.h"
 1199               		.file 6 "/usr/lib/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccrNmLlH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccrNmLlH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccrNmLlH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccrNmLlH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccrNmLlH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccrNmLlH.s:12     .text:0000000000000000 set_bits
     /tmp/ccrNmLlH.s:98     .text:000000000000005a clear_bits
     /tmp/ccrNmLlH.s:181    .text:00000000000000b2 put_lcd_data
     /tmp/ccrNmLlH.s:382    .text:000000000000016a lcd_write
     /tmp/ccrNmLlH.s:488    .text:00000000000001c4 lcd_write_string
     /tmp/ccrNmLlH.s:645    .text:000000000000025c put_lcd_nibble
     /tmp/ccrNmLlH.s:781    .text:00000000000002da debug_pin
     /tmp/ccrNmLlH.s:859    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
get_lcd_busy_flag
sprintf
__do_copy_data
