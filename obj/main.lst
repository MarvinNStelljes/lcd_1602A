   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	put_lcd_nibble
  12               	put_lcd_nibble:
  13               	.LFB15:
  14               		.file 1 "main.c"
   1:main.c        **** /* Alle Zeichen zwischen Schrägstrich-Stern 
   2:main.c        ****    und Stern-Schrägstrich sind Kommentare */
   3:main.c        **** 
   4:main.c        **** // Zeilenkommentare sind ebenfalls möglich
   5:main.c        **** // alle auf die beiden Schrägstriche folgenden
   6:main.c        **** // Zeichen einer Zeile sind Kommentar
   7:main.c        **** 
   8:main.c        **** 
   9:main.c        **** 
  10:main.c        **** #include "main.h"
  11:main.c        **** #include <avr/io.h> 
  12:main.c        **** #include <util/delay.h>
  13:main.c        **** #include <stdio.h>
  14:main.c        **** #include <stdlib.h>
  15:main.c        **** 
  16:main.c        **** #include <stdarg.h>
  17:main.c        **** 
  18:main.c        **** 
  19:main.c        **** #include "lcd_1602A.h"
  20:main.c        **** #include "atmel_io_control.h"
  21:main.c        **** #include "atmel_pin_config.h"
  22:main.c        **** 
  23:main.c        **** 
  24:main.c        **** 
  25:main.c        **** 	
  26:main.c        **** void lcd_write(unsigned char character);
  27:main.c        **** void lcd_write_string(char *string);
  28:main.c        **** void put_lcd_data(uint8_t data);
  29:main.c        **** void put_lcd_nibble(uint8_t data);
  30:main.c        **** void debug_pin(uint8_t bit);
  31:main.c        **** 
  32:main.c        **** 
  33:main.c        **** 
  34:main.c        **** int main (void) {   
  35:main.c        **** 
  36:main.c        **** 	
  37:main.c        **** 
  38:main.c        **** 
  39:main.c        **** 	
  40:main.c        **** 	_delay_ms (20);
  41:main.c        **** 	
  42:main.c        **** 	configurate_pins();
  43:main.c        **** 	
  44:main.c        **** 		DDRB = 0xFF;             // (3)
  45:main.c        ****             
  46:main.c        **** 	DDRD = 0xFF;         // (2)
  47:main.c        **** 
  48:main.c        ****                
  49:main.c        ****  
  50:main.c        ****     clear_bits(&PORTD, 2, RS_PIN, RW_PIN);
  51:main.c        ****    _delay_ms (10); 
  52:main.c        ****  
  53:main.c        **** put_lcd_nibble(0x03);
  54:main.c        **** _delay_ms (4.1);
  55:main.c        **** 
  56:main.c        **** put_lcd_nibble(0x03);
  57:main.c        **** _delay_us (100);
  58:main.c        **** 
  59:main.c        ****             
  60:main.c        **** 
  61:main.c        **** 
  62:main.c        **** 
  63:main.c        **** put_lcd_nibble(0x03);
  64:main.c        **** _delay_ms (4.1);
  65:main.c        **** put_lcd_nibble(0x02);
  66:main.c        **** _delay_ms (4.1);
  67:main.c        **** 
  68:main.c        **** 
  69:main.c        **** 
  70:main.c        **** put_lcd_data(LCD_FUNCTION_SET | LCD_SET_4BIT_MODE | LCD_SET_2LINE_MODE | LCD_FONT_5X8_MODE);	
  71:main.c        **** 
  72:main.c        ****   
  73:main.c        **** 
  74:main.c        **** put_lcd_data(LCD_DISPLAY_OFF);
  75:main.c        **** 
  76:main.c        **** put_lcd_data(LCD_CLEAR_DISPLAY);	
  77:main.c        **** 
  78:main.c        **** //Entry Mode
  79:main.c        **** 
  80:main.c        **** put_lcd_data(LCD_ENTRY_MODE | LCD_CURSOR_INC_DIR_RIGHT| LCD_SHIFT_OFF);
  81:main.c        **** 
  82:main.c        **** 
  83:main.c        **** put_lcd_data(LCD_DISPLAY_ON | LCD_CURSOR_ON | LCD_CURSOR_BLINK_ON);
  84:main.c        **** 
  85:main.c        ****  
  86:main.c        **** 
  87:main.c        **** //----------------------------------------------------------------------
  88:main.c        **** 	char formatted_string[40];
  89:main.c        **** 
  90:main.c        **** 
  91:main.c        **** 
  92:main.c        **** 
  93:main.c        **** 
  94:main.c        ****    	lcd_write_string("Na das war aber eine schwere Geburt");
  95:main.c        ****    	 _delay_ms (2000);
  96:main.c        ****          
  97:main.c        ****    	put_lcd_data(LCD_CLEAR_DISPLAY);
  98:main.c        ****   
  99:main.c        ****    	
 100:main.c        **** 	lcd_write_string("Und das alles wegen einem schlechten Datenblatt...");
 101:main.c        **** 	_delay_ms (2000);
 102:main.c        **** 	put_lcd_data(LCD_CLEAR_DISPLAY);
 103:main.c        **** 	
 104:main.c        **** 	
 105:main.c        **** 	sprintf(formatted_string, "DMSG: PORTB:%x",PORTB);
 106:main.c        **** 	lcd_write_string(formatted_string);
 107:main.c        **** 	_delay_ms (2000);
 108:main.c        **** 	
 109:main.c        **** 		
 110:main.c        **** 	DDRB &=	~(1 << SENSOR);
 111:main.c        **** 	_delay_ms (20);
 112:main.c        **** 	
 113:main.c        **** 		
 114:main.c        **** 	put_lcd_data(LCD_CLEAR_DISPLAY);	
 115:main.c        **** 		
 116:main.c        **** 		
 117:main.c        **** 	while(1) {                
 118:main.c        ****      
 119:main.c        ****         debug_pin(PORTB0);
 120:main.c        ****         
 121:main.c        **** 	sprintf(formatted_string, "SENSOR: %x",(PINB & (1 << PINB2)));
 122:main.c        **** 	lcd_write_string(formatted_string);
 123:main.c        **** 	
 124:main.c        **** 	put_lcd_data(LCD_CARRIAGE_RETURN);
 125:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 126:main.c        **** 	
 127:main.c        **** 	_delay_ms (1000);	
 128:main.c        ****         
 129:main.c        ****         
 130:main.c        ****    }        
 131:main.c        **** 		
 132:main.c        **** 		
 133:main.c        **** 	
 134:main.c        **** 	
 135:main.c        ****    while(1) {                
 136:main.c        ****      
 137:main.c        ****         debug_pin(PORTB0);
 138:main.c        ****    }                        
 139:main.c        **** 
 140:main.c        ****    /* wird nie erreicht */
 141:main.c        ****    return 0;                 
 142:main.c        **** }
 143:main.c        **** 
 144:main.c        **** 
 145:main.c        **** 
 146:main.c        **** 
 147:main.c        **** 
 148:main.c        **** 
 149:main.c        **** 
 150:main.c        **** 	
 151:main.c        **** 	void lcd_write(unsigned char character)
 152:main.c        **** 	{
 153:main.c        **** 		
 154:main.c        **** 		
 155:main.c        **** 			 set_bits(&RS_PORT, 1, RS_PIN); 
 156:main.c        **** 	
 157:main.c        ****    _delay_ms (1); 
 158:main.c        **** 	
 159:main.c        **** 	 put_lcd_data(character);
 160:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 161:main.c        **** 
 162:main.c        **** 	
 163:main.c        **** 		
 164:main.c        **** 	
 165:main.c        **** 		
 166:main.c        **** 	clear_bits(&RS_PORT, 1, RS_PIN);
 167:main.c        **** 	
 168:main.c        **** 
 169:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 170:main.c        **** }
 171:main.c        **** 	
 172:main.c        **** 
 173:main.c        **** void lcd_write_string(char *string)
 174:main.c        **** {
 175:main.c        **** 	int cnt = 0; 
 176:main.c        **** 	
 177:main.c        **** 	while(*string != 0) {
 178:main.c        **** 			
 179:main.c        **** 		set_bits(&RS_PORT, 1, RS_PIN); 
 180:main.c        **** 		
 181:main.c        **** 		_delay_ms (1);
 182:main.c        **** 		
 183:main.c        **** 		put_lcd_data(*string);
 184:main.c        **** 		//while(get_lcd_busy_flag() > 0);	
 185:main.c        **** 					
 186:main.c        **** 		clear_bits(&RS_PORT, 1, RS_PIN);
 187:main.c        **** 			
 188:main.c        **** 		if (cnt == 15)
 189:main.c        **** 		{
 190:main.c        **** 			//carriage return
 191:main.c        **** 		
 192:main.c        **** 		put_lcd_data(LCD_CARRIAGE_RETURN);
 193:main.c        **** 		//while(get_lcd_busy_flag() > 0);
 194:main.c        **** 		}
 195:main.c        **** 		string++;
 196:main.c        **** 		cnt++;
 197:main.c        **** 		
 198:main.c        **** 		
 199:main.c        **** 		}
 200:main.c        **** 	}
 201:main.c        **** 	
 202:main.c        **** 	
 203:main.c        **** 	
 204:main.c        **** void put_lcd_data(uint8_t data)	
 205:main.c        **** {
 206:main.c        **** 	LCD_DATA &= ~((1 << LCD_D7) | (1 << LCD_D6) | (1 << LCD_D5) | (1 << LCD_D4));
 207:main.c        **** 	
 208:main.c        **** 	if ((data & BIT7) != 0)
 209:main.c        **** 		LCD_DATA |= (1 << LCD_D7);
 210:main.c        **** 	if ((data & BIT6) != 0)
 211:main.c        **** 		LCD_DATA |= (1 << LCD_D6);
 212:main.c        **** 	if ((data & BIT5) != 0)
 213:main.c        **** 		LCD_DATA |= (1 << LCD_D5);
 214:main.c        **** 	if ((data & BIT4) != 0)
 215:main.c        **** 		LCD_DATA |= (1 << LCD_D4);
 216:main.c        **** 
 217:main.c        **** 
 218:main.c        **** toggle_LCD_EN_test(&LCD_EN_test);
 219:main.c        **** //toggle_LCD_EN(&PORTB, LCD_EN);
 220:main.c        **** 	LCD_DATA &= ~((1 << LCD_D4) | (1 << LCD_D5) | (1 << LCD_D6) | (1 << LCD_D7));
 221:main.c        **** 
 222:main.c        **** 	if ((data & BIT3) != 0)
 223:main.c        **** 		LCD_DATA |= (1 << LCD_D7);
 224:main.c        **** 	if ((data & BIT2) != 0)
 225:main.c        **** 		LCD_DATA |= (1 << LCD_D6);
 226:main.c        **** 	if ((data & BIT1) != 0)
 227:main.c        **** 		LCD_DATA |= (1 << LCD_D5);
 228:main.c        **** 	if ((data & BIT0) != 0)
 229:main.c        **** 		LCD_DATA |= (1 << LCD_D4);
 230:main.c        **** 
 231:main.c        **** 	toggle_LCD_EN(&PORTB, LCD_EN);
 232:main.c        **** 
 233:main.c        **** 	
 234:main.c        **** 	
 235:main.c        **** 	while(get_lcd_busy_flag() > 0);  //Der ist wichtig!!!
 236:main.c        **** 	
 237:main.c        **** 
 238:main.c        **** 		
 239:main.c        **** }
 240:main.c        **** 
 241:main.c        **** void put_lcd_nibble(uint8_t data)	
 242:main.c        **** {
  15               		.loc 1 242 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.LBB48:
  23               	.LBB49:
  24               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  25               		.loc 2 187 0
  26 0000 2FEF      		ldi r18,lo8(319999)
  27 0002 31EE      		ldi r19,hi8(319999)
  28 0004 94E0      		ldi r25,hlo8(319999)
  29 0006 2150      	1:	subi r18,1
  30 0008 3040      		sbci r19,0
  31 000a 9040      		sbci r25,0
  32 000c 01F4      		brne 1b
  33 000e 00C0      		rjmp .
  34 0010 0000      		nop
  35               	.LVL1:
  36               	.LBE49:
  37               	.LBE48:
 243:main.c        ****    _delay_ms (100);
 244:main.c        **** 	LCD_DATA &= ~((1 << LCD_D7) | (1 << LCD_D6) | (1 << LCD_D5) | (1 << LCD_D4));
  38               		.loc 1 244 0
  39 0012 9BB1      		in r25,0xb
  40 0014 9F70      		andi r25,lo8(15)
  41 0016 9BB9      		out 0xb,r25
 245:main.c        **** 	
 246:main.c        **** 	if ((data & BIT3) != 0)
  42               		.loc 1 246 0
  43 0018 83FD      		sbrc r24,3
 247:main.c        **** 		LCD_DATA |= (1 << LCD_D7);
  44               		.loc 1 247 0
  45 001a 5F9A      		sbi 0xb,7
  46               	.L2:
 248:main.c        **** 	if ((data & BIT2) != 0)
  47               		.loc 1 248 0
  48 001c 82FD      		sbrc r24,2
 249:main.c        **** 		LCD_DATA |= (1 << LCD_D6);
  49               		.loc 1 249 0
  50 001e 5E9A      		sbi 0xb,6
  51               	.L3:
 250:main.c        **** 	if ((data & BIT1) != 0)
  52               		.loc 1 250 0
  53 0020 81FD      		sbrc r24,1
 251:main.c        **** 		LCD_DATA |= (1 << LCD_D5);
  54               		.loc 1 251 0
  55 0022 5D9A      		sbi 0xb,5
  56               	.L4:
 252:main.c        **** 	if ((data & BIT0) != 0)
  57               		.loc 1 252 0
  58 0024 80FD      		sbrc r24,0
 253:main.c        **** 		LCD_DATA |= (1 << LCD_D4);
  59               		.loc 1 253 0
  60 0026 5C9A      		sbi 0xb,4
  61               	.L5:
  62               	.LVL2:
  63               	.LBB50:
  64               	.LBB51:
  65               		.loc 2 187 0
  66 0028 2FEF      		ldi r18,lo8(319999)
  67 002a 31EE      		ldi r19,hi8(319999)
  68 002c 84E0      		ldi r24,hlo8(319999)
  69 002e 2150      	1:	subi r18,1
  70 0030 3040      		sbci r19,0
  71 0032 8040      		sbci r24,0
  72 0034 01F4      		brne 1b
  73               	.LVL3:
  74 0036 00C0      		rjmp .
  75 0038 0000      		nop
  76               	.LVL4:
  77               	.LBE51:
  78               	.LBE50:
 254:main.c        **** 	_delay_ms (100);
 255:main.c        **** 	toggle_LCD_EN(&PORTB, LCD_EN);
  79               		.loc 1 255 0
  80 003a 64E0      		ldi r22,lo8(4)
  81 003c 70E0      		ldi r23,0
  82 003e 85E2      		ldi r24,lo8(37)
  83 0040 90E0      		ldi r25,0
  84 0042 0C94 0000 		jmp toggle_LCD_EN
  85               	.LVL5:
  86               		.cfi_endproc
  87               	.LFE15:
  89               	.global	debug_pin
  91               	debug_pin:
  92               	.LFB16:
 256:main.c        **** }	
 257:main.c        **** 
 258:main.c        **** 
 259:main.c        **** 
 260:main.c        **** void   debug_pin(uint8_t bit)                                                                      
 261:main.c        **** {
  93               		.loc 1 261 0
  94               		.cfi_startproc
  95               	.LVL6:
  96               	/* prologue: function */
  97               	/* frame size = 0 */
  98               	/* stack size = 0 */
  99               	.L__stack_usage = 0
 262:main.c        **** 		PORTB |= (1 << bit);
 100               		.loc 1 262 0
 101 0046 45B1      		in r20,0x5
 102 0048 21E0      		ldi r18,lo8(1)
 103 004a 30E0      		ldi r19,0
 104 004c B901      		movw r22,r18
 105 004e 00C0      		rjmp 2f
 106               		1:
 107 0050 660F      		lsl r22
 108 0052 771F      		rol r23
 109               		2:
 110 0054 8A95      		dec r24
 111 0056 02F4      		brpl 1b
 112 0058 CB01      		movw r24,r22
 113               	.LVL7:
 114 005a 462B      		or r20,r22
 115 005c 45B9      		out 0x5,r20
 116               	.LVL8:
 117               	.LBB52:
 118               	.LBB53:
 119               		.loc 2 187 0
 120 005e 7FEF      		ldi r23,lo8(3199999)
 121 0060 23ED      		ldi r18,hi8(3199999)
 122 0062 30E3      		ldi r19,hlo8(3199999)
 123 0064 7150      	1:	subi r23,1
 124 0066 2040      		sbci r18,0
 125 0068 3040      		sbci r19,0
 126 006a 01F4      		brne 1b
 127 006c 00C0      		rjmp .
 128 006e 0000      		nop
 129               	.LVL9:
 130               	.LBE53:
 131               	.LBE52:
 263:main.c        **** 		_delay_ms (1000);
 264:main.c        **** 		PORTB &= ~(1 << bit);
 132               		.loc 1 264 0
 133 0070 95B1      		in r25,0x5
 134 0072 8095      		com r24
 135 0074 8923      		and r24,r25
 136 0076 85B9      		out 0x5,r24
 137               	.LVL10:
 138               	.LBB54:
 139               	.LBB55:
 140               		.loc 2 187 0
 141 0078 4FEF      		ldi r20,lo8(3199999)
 142 007a 63ED      		ldi r22,hi8(3199999)
 143 007c 70E3      		ldi r23,hlo8(3199999)
 144 007e 4150      	1:	subi r20,1
 145 0080 6040      		sbci r22,0
 146 0082 7040      		sbci r23,0
 147 0084 01F4      		brne 1b
 148 0086 00C0      		rjmp .
 149 0088 0000      		nop
 150               	.LVL11:
 151 008a 0895      		ret
 152               	.LBE55:
 153               	.LBE54:
 154               		.cfi_endproc
 155               	.LFE16:
 157               	.global	get_lcd_busy_flag
 159               	get_lcd_busy_flag:
 160               	.LFB17:
 265:main.c        **** 		_delay_ms (1000);
 266:main.c        **** }
 267:main.c        **** 	
 268:main.c        **** 
 269:main.c        **** 
 270:main.c        **** 
 271:main.c        **** int get_lcd_busy_flag(void)
 272:main.c        **** {
 161               		.loc 1 272 0
 162               		.cfi_startproc
 163 008c 0F93      		push r16
 164               	.LCFI0:
 165               		.cfi_def_cfa_offset 3
 166               		.cfi_offset 16, -2
 167 008e 1F93      		push r17
 168               	.LCFI1:
 169               		.cfi_def_cfa_offset 4
 170               		.cfi_offset 17, -3
 171 0090 CF93      		push r28
 172               	.LCFI2:
 173               		.cfi_def_cfa_offset 5
 174               		.cfi_offset 28, -4
 175 0092 DF93      		push r29
 176               	.LCFI3:
 177               		.cfi_def_cfa_offset 6
 178               		.cfi_offset 29, -5
 179               	/* prologue: function */
 180               	/* frame size = 0 */
 181               	/* stack size = 4 */
 182               	.L__stack_usage = 4
 183               	.LVL12:
 273:main.c        **** 	// TODO: add address counter
 274:main.c        **** 
 275:main.c        **** 	uint8_t input_buffer = 0;
 276:main.c        **** 	
 277:main.c        **** 	DDRD &= ~( (1 << LCD_D7) | (1 << LCD_D6) | (1 << LCD_D5) | (1 << LCD_D4));	// Set LCD Port Pins as
 184               		.loc 1 277 0
 185 0094 8AB1      		in r24,0xa
 186 0096 8F70      		andi r24,lo8(15)
 187 0098 8AB9      		out 0xa,r24
 278:main.c        **** 	
 279:main.c        **** 	clear_bits(&RS_PORT, 1, RS_PIN);
 188               		.loc 1 279 0
 189 009a 1F92      		push __zero_reg__
 190               	.LCFI4:
 191               		.cfi_def_cfa_offset 7
 192 009c 82E0      		ldi r24,lo8(2)
 193 009e 8F93      		push r24
 194               	.LCFI5:
 195               		.cfi_def_cfa_offset 8
 196 00a0 C1E0      		ldi r28,lo8(1)
 197 00a2 CF93      		push r28
 198               	.LCFI6:
 199               		.cfi_def_cfa_offset 9
 200 00a4 1F92      		push __zero_reg__
 201               	.LCFI7:
 202               		.cfi_def_cfa_offset 10
 203 00a6 DBE2      		ldi r29,lo8(43)
 204 00a8 DF93      		push r29
 205               	.LCFI8:
 206               		.cfi_def_cfa_offset 11
 207 00aa 0E94 0000 		call clear_bits
 208               	.LVL13:
 280:main.c        **** 	set_bits(&RW_PORT, 1, RW_PIN); 
 209               		.loc 1 280 0
 210 00ae 1F92      		push __zero_reg__
 211               	.LCFI9:
 212               		.cfi_def_cfa_offset 12
 213 00b0 83E0      		ldi r24,lo8(3)
 214 00b2 8F93      		push r24
 215               	.LCFI10:
 216               		.cfi_def_cfa_offset 13
 217 00b4 CF93      		push r28
 218               	.LCFI11:
 219               		.cfi_def_cfa_offset 14
 220 00b6 1F92      		push __zero_reg__
 221               	.LCFI12:
 222               		.cfi_def_cfa_offset 15
 223 00b8 DF93      		push r29
 224               	.LCFI13:
 225               		.cfi_def_cfa_offset 16
 226 00ba 0E94 0000 		call set_bits
 227               	.LVL14:
 228               	.LBB56:
 229               	.LBB57:
 230               		.loc 2 187 0
 231 00be 8FE9      		ldi r24,lo8(3999)
 232 00c0 9FE0      		ldi r25,hi8(3999)
 233 00c2 0197      	1:	sbiw r24,1
 234 00c4 01F4      		brne 1b
 235 00c6 00C0      		rjmp .
 236 00c8 0000      		nop
 237               	.LVL15:
 238               	.LBE57:
 239               	.LBE56:
 281:main.c        **** 	_delay_ms (1);
 282:main.c        **** 	
 283:main.c        **** 	
 284:main.c        **** 	set_bits(&PORTB, 1, LCD_EN);
 240               		.loc 1 284 0
 241 00ca 1F92      		push __zero_reg__
 242               	.LCFI14:
 243               		.cfi_def_cfa_offset 17
 244 00cc 84E0      		ldi r24,lo8(4)
 245 00ce 8F93      		push r24
 246               	.LCFI15:
 247               		.cfi_def_cfa_offset 18
 248 00d0 CF93      		push r28
 249               	.LCFI16:
 250               		.cfi_def_cfa_offset 19
 251 00d2 1F92      		push __zero_reg__
 252               	.LCFI17:
 253               		.cfi_def_cfa_offset 20
 254 00d4 85E2      		ldi r24,lo8(37)
 255 00d6 8F93      		push r24
 256               	.LCFI18:
 257               		.cfi_def_cfa_offset 21
 258 00d8 0E94 0000 		call set_bits
 259               	.LVL16:
 260               	.LBB58:
 261               	.LBB59:
 262               		.loc 2 187 0
 263 00dc 8FE9      		ldi r24,lo8(3999)
 264 00de 9FE0      		ldi r25,hi8(3999)
 265 00e0 0197      	1:	sbiw r24,1
 266 00e2 01F4      		brne 1b
 267 00e4 00C0      		rjmp .
 268 00e6 0000      		nop
 269               	.LVL17:
 270               	.LBE59:
 271               	.LBE58:
 285:main.c        **** 	_delay_ms (1);
 286:main.c        **** 	
 287:main.c        **** 	if ((LCD_DATA_IN & (1 << LCD_D7)) != 0)
 272               		.loc 1 287 0
 273 00e8 2DB7      		in r18,__SP_L__
 274 00ea 3EB7      		in r19,__SP_H__
 275 00ec 215F      		subi r18,-15
 276 00ee 3F4F      		sbci r19,-1
 277 00f0 0FB6      		in __tmp_reg__,__SREG__
 278 00f2 F894      		cli
 279 00f4 3EBF      		out __SP_H__,r19
 280 00f6 0FBE      		out __SREG__,__tmp_reg__
 281 00f8 2DBF      		out __SP_L__,r18
 282               	.LCFI19:
 283               		.cfi_def_cfa_offset 6
 284 00fa 4F9B      		sbis 0x9,7
 285 00fc 00C0      		rjmp .L29
 288:main.c        **** 		input_buffer |= (1 << 7);
 286               		.loc 1 288 0
 287 00fe C0E8      		ldi r28,lo8(-128)
 288 0100 00C0      		rjmp .L21
 289               	.L29:
 275:main.c        **** 	
 290               		.loc 1 275 0
 291 0102 C0E0      		ldi r28,0
 292               	.L21:
 293               	.LVL18:
 289:main.c        **** 	if ((LCD_DATA_IN & (1 << LCD_D6)) != 0)
 294               		.loc 1 289 0
 295 0104 4E99      		sbic 0x9,6
 290:main.c        **** 		input_buffer |= (1 << 6);
 296               		.loc 1 290 0
 297 0106 C064      		ori r28,lo8(64)
 298               	.LVL19:
 299               	.L22:
 291:main.c        **** 	if ((LCD_DATA_IN & (1 << LCD_D5)) != 0)
 300               		.loc 1 291 0
 301 0108 4D99      		sbic 0x9,5
 292:main.c        **** 		input_buffer |= (1 << 5);
 302               		.loc 1 292 0
 303 010a C062      		ori r28,lo8(32)
 304               	.LVL20:
 305               	.L23:
 293:main.c        **** 	if ((LCD_DATA_IN & (1 << LCD_D4)) != 0)
 306               		.loc 1 293 0
 307 010c 4C99      		sbic 0x9,4
 294:main.c        **** 		input_buffer |= (1 << 4);
 308               		.loc 1 294 0
 309 010e C061      		ori r28,lo8(16)
 310               	.LVL21:
 311               	.L24:
 312               	.LBB60:
 313               	.LBB61:
 314               		.loc 2 187 0
 315 0110 8FE9      		ldi r24,lo8(3999)
 316 0112 9FE0      		ldi r25,hi8(3999)
 317 0114 0197      	1:	sbiw r24,1
 318 0116 01F4      		brne 1b
 319 0118 00C0      		rjmp .
 320 011a 0000      		nop
 321               	.LVL22:
 322               	.LBE61:
 323               	.LBE60:
 295:main.c        **** 		_delay_ms (1);
 296:main.c        **** 	
 297:main.c        **** 	clear_bits(&PORTB, 1, LCD_EN);
 324               		.loc 1 297 0
 325 011c 1F92      		push __zero_reg__
 326               	.LCFI20:
 327               		.cfi_def_cfa_offset 7
 328 011e 04E0      		ldi r16,lo8(4)
 329 0120 0F93      		push r16
 330               	.LCFI21:
 331               		.cfi_def_cfa_offset 8
 332 0122 11E0      		ldi r17,lo8(1)
 333 0124 1F93      		push r17
 334               	.LCFI22:
 335               		.cfi_def_cfa_offset 9
 336 0126 1F92      		push __zero_reg__
 337               	.LCFI23:
 338               		.cfi_def_cfa_offset 10
 339 0128 D5E2      		ldi r29,lo8(37)
 340 012a DF93      		push r29
 341               	.LCFI24:
 342               		.cfi_def_cfa_offset 11
 343 012c 0E94 0000 		call clear_bits
 344               	.LVL23:
 345               	.LBB62:
 346               	.LBB63:
 347               		.loc 2 187 0
 348 0130 8FE9      		ldi r24,lo8(3999)
 349 0132 9FE0      		ldi r25,hi8(3999)
 350 0134 0197      	1:	sbiw r24,1
 351 0136 01F4      		brne 1b
 352 0138 00C0      		rjmp .
 353 013a 0000      		nop
 354               	.LVL24:
 355               	.LBE63:
 356               	.LBE62:
 298:main.c        ****    
 299:main.c        ****    _delay_ms (1);
 300:main.c        **** 	set_bits(&PORTB, 1, LCD_EN);
 357               		.loc 1 300 0
 358 013c 1F92      		push __zero_reg__
 359               	.LCFI25:
 360               		.cfi_def_cfa_offset 12
 361 013e 0F93      		push r16
 362               	.LCFI26:
 363               		.cfi_def_cfa_offset 13
 364 0140 1F93      		push r17
 365               	.LCFI27:
 366               		.cfi_def_cfa_offset 14
 367 0142 1F92      		push __zero_reg__
 368               	.LCFI28:
 369               		.cfi_def_cfa_offset 15
 370 0144 DF93      		push r29
 371               	.LCFI29:
 372               		.cfi_def_cfa_offset 16
 373 0146 0E94 0000 		call set_bits
 374               	.LVL25:
 375               	.LBB64:
 376               	.LBB65:
 377               		.loc 2 187 0
 378 014a 8FE9      		ldi r24,lo8(3999)
 379 014c 9FE0      		ldi r25,hi8(3999)
 380 014e 0197      	1:	sbiw r24,1
 381 0150 01F4      		brne 1b
 382 0152 00C0      		rjmp .
 383 0154 0000      		nop
 384               	.LVL26:
 385               	.LBE65:
 386               	.LBE64:
 301:main.c        **** 	_delay_ms (1);
 302:main.c        **** 	
 303:main.c        **** 	if ((LCD_DATA_IN & (1 << LCD_D7)) != 0)
 387               		.loc 1 303 0
 388 0156 2DB7      		in r18,__SP_L__
 389 0158 3EB7      		in r19,__SP_H__
 390 015a 265F      		subi r18,-10
 391 015c 3F4F      		sbci r19,-1
 392 015e 0FB6      		in __tmp_reg__,__SREG__
 393 0160 F894      		cli
 394 0162 3EBF      		out __SP_H__,r19
 395 0164 0FBE      		out __SREG__,__tmp_reg__
 396 0166 2DBF      		out __SP_L__,r18
 397               	.LCFI30:
 398               		.cfi_def_cfa_offset 6
 399 0168 4F99      		sbic 0x9,7
 304:main.c        **** 		input_buffer |= (1 << 3);
 400               		.loc 1 304 0
 401 016a C860      		ori r28,lo8(8)
 402               	.LVL27:
 403               	.L25:
 305:main.c        **** 	if ((LCD_DATA_IN & (1 << LCD_D6)) != 0)
 404               		.loc 1 305 0
 405 016c 4E99      		sbic 0x9,6
 306:main.c        **** 		input_buffer |= (1 << 2);
 406               		.loc 1 306 0
 407 016e C460      		ori r28,lo8(4)
 408               	.LVL28:
 409               	.L26:
 307:main.c        **** 	if ((LCD_DATA_IN & (1 << LCD_D5)) != 0)
 410               		.loc 1 307 0
 411 0170 4D99      		sbic 0x9,5
 308:main.c        **** 		input_buffer |= (1 << 1);
 412               		.loc 1 308 0
 413 0172 C260      		ori r28,lo8(2)
 414               	.LVL29:
 415               	.L27:
 309:main.c        **** 	if ((LCD_DATA_IN & (1 << LCD_D4)) != 0)
 416               		.loc 1 309 0
 417 0174 4C99      		sbic 0x9,4
 310:main.c        **** 		input_buffer |= (1 << 0);
 418               		.loc 1 310 0
 419 0176 C160      		ori r28,lo8(1)
 420               	.LVL30:
 421               	.L28:
 422               	.LBB66:
 423               	.LBB67:
 424               		.loc 2 187 0
 425 0178 8FE9      		ldi r24,lo8(3999)
 426 017a 9FE0      		ldi r25,hi8(3999)
 427 017c 0197      	1:	sbiw r24,1
 428 017e 01F4      		brne 1b
 429 0180 00C0      		rjmp .
 430 0182 0000      		nop
 431               	.LVL31:
 432               	.LBE67:
 433               	.LBE66:
 311:main.c        **** 	_delay_ms (1);
 312:main.c        **** 	clear_bits(&PORTB, 1, LCD_EN);
 434               		.loc 1 312 0
 435 0184 1F92      		push __zero_reg__
 436               	.LCFI31:
 437               		.cfi_def_cfa_offset 7
 438 0186 84E0      		ldi r24,lo8(4)
 439 0188 8F93      		push r24
 440               	.LCFI32:
 441               		.cfi_def_cfa_offset 8
 442 018a D1E0      		ldi r29,lo8(1)
 443 018c DF93      		push r29
 444               	.LCFI33:
 445               		.cfi_def_cfa_offset 9
 446 018e 1F92      		push __zero_reg__
 447               	.LCFI34:
 448               		.cfi_def_cfa_offset 10
 449 0190 85E2      		ldi r24,lo8(37)
 450 0192 8F93      		push r24
 451               	.LCFI35:
 452               		.cfi_def_cfa_offset 11
 453 0194 0E94 0000 		call clear_bits
 454               	.LVL32:
 313:main.c        **** 	clear_bits(&RW_PORT, 1, RW_PIN);
 455               		.loc 1 313 0
 456 0198 1F92      		push __zero_reg__
 457               	.LCFI36:
 458               		.cfi_def_cfa_offset 12
 459 019a 83E0      		ldi r24,lo8(3)
 460 019c 8F93      		push r24
 461               	.LCFI37:
 462               		.cfi_def_cfa_offset 13
 463 019e DF93      		push r29
 464               	.LCFI38:
 465               		.cfi_def_cfa_offset 14
 466 01a0 1F92      		push __zero_reg__
 467               	.LCFI39:
 468               		.cfi_def_cfa_offset 15
 469 01a2 8BE2      		ldi r24,lo8(43)
 470 01a4 8F93      		push r24
 471               	.LCFI40:
 472               		.cfi_def_cfa_offset 16
 473 01a6 0E94 0000 		call clear_bits
 474               	.LVL33:
 314:main.c        **** 	
 315:main.c        **** 	DDRD |= ((1 << LCD_D7) | (1 << LCD_D6) | (1 << LCD_D5) | (1 << LCD_D4));	// Set LCD Port Pins as O
 475               		.loc 1 315 0
 476 01aa 8AB1      		in r24,0xa
 477 01ac 806F      		ori r24,lo8(-16)
 478 01ae 8AB9      		out 0xa,r24
 316:main.c        **** 
 317:main.c        **** 
 318:main.c        **** 	return ( input_buffer & 0b10000000);
 479               		.loc 1 318 0
 480 01b0 8C2F      		mov r24,r28
 481 01b2 8078      		andi r24,lo8(-128)
 482 01b4 2DB7      		in r18,__SP_L__
 483 01b6 3EB7      		in r19,__SP_H__
 484 01b8 265F      		subi r18,-10
 485 01ba 3F4F      		sbci r19,-1
 486 01bc 0FB6      		in __tmp_reg__,__SREG__
 487 01be F894      		cli
 488 01c0 3EBF      		out __SP_H__,r19
 489 01c2 0FBE      		out __SREG__,__tmp_reg__
 490 01c4 2DBF      		out __SP_L__,r18
 491               	.LCFI41:
 492               		.cfi_def_cfa_offset 6
 319:main.c        **** }
 493               		.loc 1 319 0
 494 01c6 90E0      		ldi r25,0
 495               	/* epilogue start */
 496 01c8 DF91      		pop r29
 497 01ca CF91      		pop r28
 498               	.LVL34:
 499 01cc 1F91      		pop r17
 500 01ce 0F91      		pop r16
 501 01d0 0895      		ret
 502               		.cfi_endproc
 503               	.LFE17:
 505               	.global	put_lcd_data
 507               	put_lcd_data:
 508               	.LFB14:
 205:main.c        **** 	LCD_DATA &= ~((1 << LCD_D7) | (1 << LCD_D6) | (1 << LCD_D5) | (1 << LCD_D4));
 509               		.loc 1 205 0
 510               		.cfi_startproc
 511               	.LVL35:
 512 01d2 CF93      		push r28
 513               	.LCFI42:
 514               		.cfi_def_cfa_offset 3
 515               		.cfi_offset 28, -2
 516               	/* prologue: function */
 517               	/* frame size = 0 */
 518               	/* stack size = 1 */
 519               	.L__stack_usage = 1
 520 01d4 C82F      		mov r28,r24
 206:main.c        **** 	
 521               		.loc 1 206 0
 522 01d6 8BB1      		in r24,0xb
 523               	.LVL36:
 524 01d8 8F70      		andi r24,lo8(15)
 525 01da 8BB9      		out 0xb,r24
 208:main.c        **** 		LCD_DATA |= (1 << LCD_D7);
 526               		.loc 1 208 0
 527 01dc C7FD      		sbrc r28,7
 209:main.c        **** 	if ((data & BIT6) != 0)
 528               		.loc 1 209 0
 529 01de 5F9A      		sbi 0xb,7
 530               	.L49:
 210:main.c        **** 		LCD_DATA |= (1 << LCD_D6);
 531               		.loc 1 210 0
 532 01e0 C6FD      		sbrc r28,6
 211:main.c        **** 	if ((data & BIT5) != 0)
 533               		.loc 1 211 0
 534 01e2 5E9A      		sbi 0xb,6
 535               	.L50:
 212:main.c        **** 		LCD_DATA |= (1 << LCD_D5);
 536               		.loc 1 212 0
 537 01e4 C5FD      		sbrc r28,5
 213:main.c        **** 	if ((data & BIT4) != 0)
 538               		.loc 1 213 0
 539 01e6 5D9A      		sbi 0xb,5
 540               	.L51:
 214:main.c        **** 		LCD_DATA |= (1 << LCD_D4);
 541               		.loc 1 214 0
 542 01e8 C4FD      		sbrc r28,4
 215:main.c        **** 
 543               		.loc 1 215 0
 544 01ea 5C9A      		sbi 0xb,4
 545               	.L52:
 218:main.c        **** //toggle_LCD_EN(&PORTB, LCD_EN);
 546               		.loc 1 218 0
 547 01ec 80E0      		ldi r24,lo8(LCD_EN_test)
 548 01ee 90E0      		ldi r25,hi8(LCD_EN_test)
 549 01f0 0E94 0000 		call toggle_LCD_EN_test
 550               	.LVL37:
 220:main.c        **** 
 551               		.loc 1 220 0
 552 01f4 8BB1      		in r24,0xb
 553 01f6 8F70      		andi r24,lo8(15)
 554 01f8 8BB9      		out 0xb,r24
 222:main.c        **** 		LCD_DATA |= (1 << LCD_D7);
 555               		.loc 1 222 0
 556 01fa C3FD      		sbrc r28,3
 223:main.c        **** 	if ((data & BIT2) != 0)
 557               		.loc 1 223 0
 558 01fc 5F9A      		sbi 0xb,7
 559               	.L53:
 224:main.c        **** 		LCD_DATA |= (1 << LCD_D6);
 560               		.loc 1 224 0
 561 01fe C2FD      		sbrc r28,2
 225:main.c        **** 	if ((data & BIT1) != 0)
 562               		.loc 1 225 0
 563 0200 5E9A      		sbi 0xb,6
 564               	.L54:
 226:main.c        **** 		LCD_DATA |= (1 << LCD_D5);
 565               		.loc 1 226 0
 566 0202 C1FD      		sbrc r28,1
 227:main.c        **** 	if ((data & BIT0) != 0)
 567               		.loc 1 227 0
 568 0204 5D9A      		sbi 0xb,5
 569               	.L55:
 228:main.c        **** 		LCD_DATA |= (1 << LCD_D4);
 570               		.loc 1 228 0
 571 0206 C0FD      		sbrc r28,0
 229:main.c        **** 
 572               		.loc 1 229 0
 573 0208 5C9A      		sbi 0xb,4
 574               	.L56:
 231:main.c        **** 
 575               		.loc 1 231 0
 576 020a 64E0      		ldi r22,lo8(4)
 577 020c 70E0      		ldi r23,0
 578 020e 85E2      		ldi r24,lo8(37)
 579 0210 90E0      		ldi r25,0
 580 0212 0E94 0000 		call toggle_LCD_EN
 581               	.LVL38:
 582               	.L57:
 235:main.c        **** 	
 583               		.loc 1 235 0 discriminator 1
 584 0216 0E94 0000 		call get_lcd_busy_flag
 585               	.LVL39:
 586 021a 1816      		cp __zero_reg__,r24
 587 021c 1906      		cpc __zero_reg__,r25
 588 021e 04F0      		brlt .L57
 589               	/* epilogue start */
 239:main.c        **** 
 590               		.loc 1 239 0
 591 0220 CF91      		pop r28
 592               	.LVL40:
 593 0222 0895      		ret
 594               		.cfi_endproc
 595               	.LFE14:
 597               	.global	lcd_write
 599               	lcd_write:
 600               	.LFB12:
 152:main.c        **** 		
 601               		.loc 1 152 0
 602               		.cfi_startproc
 603               	.LVL41:
 604 0224 0F93      		push r16
 605               	.LCFI43:
 606               		.cfi_def_cfa_offset 3
 607               		.cfi_offset 16, -2
 608 0226 1F93      		push r17
 609               	.LCFI44:
 610               		.cfi_def_cfa_offset 4
 611               		.cfi_offset 17, -3
 612 0228 CF93      		push r28
 613               	.LCFI45:
 614               		.cfi_def_cfa_offset 5
 615               		.cfi_offset 28, -4
 616 022a DF93      		push r29
 617               	.LCFI46:
 618               		.cfi_def_cfa_offset 6
 619               		.cfi_offset 29, -5
 620               	/* prologue: function */
 621               	/* frame size = 0 */
 622               	/* stack size = 4 */
 623               	.L__stack_usage = 4
 624 022c 082F      		mov r16,r24
 155:main.c        **** 	
 625               		.loc 1 155 0
 626 022e 1F92      		push __zero_reg__
 627               	.LCFI47:
 628               		.cfi_def_cfa_offset 7
 629 0230 12E0      		ldi r17,lo8(2)
 630 0232 1F93      		push r17
 631               	.LCFI48:
 632               		.cfi_def_cfa_offset 8
 633 0234 D1E0      		ldi r29,lo8(1)
 634 0236 DF93      		push r29
 635               	.LCFI49:
 636               		.cfi_def_cfa_offset 9
 637 0238 1F92      		push __zero_reg__
 638               	.LCFI50:
 639               		.cfi_def_cfa_offset 10
 640 023a CBE2      		ldi r28,lo8(43)
 641 023c CF93      		push r28
 642               	.LCFI51:
 643               		.cfi_def_cfa_offset 11
 644 023e 0E94 0000 		call set_bits
 645               	.LVL42:
 646               	.LBB68:
 647               	.LBB69:
 648               		.loc 2 187 0
 649 0242 8FE9      		ldi r24,lo8(3999)
 650 0244 9FE0      		ldi r25,hi8(3999)
 651 0246 0197      	1:	sbiw r24,1
 652 0248 01F4      		brne 1b
 653 024a 00C0      		rjmp .
 654 024c 0000      		nop
 655               	.LVL43:
 656               	.LBE69:
 657               	.LBE68:
 159:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 658               		.loc 1 159 0
 659 024e 802F      		mov r24,r16
 660 0250 0E94 0000 		call put_lcd_data
 661               	.LVL44:
 166:main.c        **** 	
 662               		.loc 1 166 0
 663 0254 1F92      		push __zero_reg__
 664               	.LCFI52:
 665               		.cfi_def_cfa_offset 12
 666 0256 1F93      		push r17
 667               	.LCFI53:
 668               		.cfi_def_cfa_offset 13
 669 0258 DF93      		push r29
 670               	.LCFI54:
 671               		.cfi_def_cfa_offset 14
 672 025a 1F92      		push __zero_reg__
 673               	.LCFI55:
 674               		.cfi_def_cfa_offset 15
 675 025c CF93      		push r28
 676               	.LCFI56:
 677               		.cfi_def_cfa_offset 16
 678 025e 0E94 0000 		call clear_bits
 679               	.LVL45:
 170:main.c        **** 	
 680               		.loc 1 170 0
 681 0262 8DB7      		in r24,__SP_L__
 682 0264 9EB7      		in r25,__SP_H__
 683 0266 0A96      		adiw r24,10
 684 0268 0FB6      		in __tmp_reg__,__SREG__
 685 026a F894      		cli
 686 026c 9EBF      		out __SP_H__,r25
 687 026e 0FBE      		out __SREG__,__tmp_reg__
 688 0270 8DBF      		out __SP_L__,r24
 689               	.LCFI57:
 690               		.cfi_def_cfa_offset 6
 691               	/* epilogue start */
 692 0272 DF91      		pop r29
 693 0274 CF91      		pop r28
 694 0276 1F91      		pop r17
 695 0278 0F91      		pop r16
 696               	.LVL46:
 697 027a 0895      		ret
 698               		.cfi_endproc
 699               	.LFE12:
 701               	.global	lcd_write_string
 703               	lcd_write_string:
 704               	.LFB13:
 174:main.c        **** 	int cnt = 0; 
 705               		.loc 1 174 0
 706               		.cfi_startproc
 707 027c AF92      		push r10
 708               	.LCFI58:
 709               		.cfi_def_cfa_offset 3
 710               		.cfi_offset 10, -2
 711 027e BF92      		push r11
 712               	.LCFI59:
 713               		.cfi_def_cfa_offset 4
 714               		.cfi_offset 11, -3
 715 0280 DF92      		push r13
 716               	.LCFI60:
 717               		.cfi_def_cfa_offset 5
 718               		.cfi_offset 13, -4
 719 0282 EF92      		push r14
 720               	.LCFI61:
 721               		.cfi_def_cfa_offset 6
 722               		.cfi_offset 14, -5
 723 0284 FF92      		push r15
 724               	.LCFI62:
 725               		.cfi_def_cfa_offset 7
 726               		.cfi_offset 15, -6
 727 0286 0F93      		push r16
 728               	.LCFI63:
 729               		.cfi_def_cfa_offset 8
 730               		.cfi_offset 16, -7
 731 0288 1F93      		push r17
 732               	.LCFI64:
 733               		.cfi_def_cfa_offset 9
 734               		.cfi_offset 17, -8
 735 028a CF93      		push r28
 736               	.LCFI65:
 737               		.cfi_def_cfa_offset 10
 738               		.cfi_offset 28, -9
 739 028c DF93      		push r29
 740               	.LCFI66:
 741               		.cfi_def_cfa_offset 11
 742               		.cfi_offset 29, -10
 743               	/* prologue: function */
 744               	/* frame size = 0 */
 745               	/* stack size = 9 */
 746               	.L__stack_usage = 9
 747 028e EC01      		movw r28,r24
 175:main.c        **** 	
 748               		.loc 1 175 0
 749 0290 00E0      		ldi r16,0
 750 0292 10E0      		ldi r17,0
 179:main.c        **** 		
 751               		.loc 1 179 0
 752 0294 82E0      		ldi r24,lo8(2)
 753 0296 F82E      		mov r15,r24
 754 0298 EE24      		clr r14
 755 029a E394      		inc r14
 756 029c 9BE2      		ldi r25,lo8(43)
 757 029e D92E      		mov r13,r25
 758               	.L82:
 759 02a0 5E01      		movw r10,r28
 177:main.c        **** 			
 760               		.loc 1 177 0
 761 02a2 8881      		ld r24,Y
 762 02a4 8823      		tst r24
 763 02a6 01F0      		breq .L85
 179:main.c        **** 		
 764               		.loc 1 179 0
 765 02a8 1F92      		push __zero_reg__
 766               	.LCFI67:
 767               		.cfi_def_cfa_offset 12
 768 02aa FF92      		push r15
 769               	.LCFI68:
 770               		.cfi_def_cfa_offset 13
 771 02ac EF92      		push r14
 772               	.LCFI69:
 773               		.cfi_def_cfa_offset 14
 774 02ae 1F92      		push __zero_reg__
 775               	.LCFI70:
 776               		.cfi_def_cfa_offset 15
 777 02b0 DF92      		push r13
 778               	.LCFI71:
 779               		.cfi_def_cfa_offset 16
 780 02b2 0E94 0000 		call set_bits
 781               	.LBB70:
 782               	.LBB71:
 783               		.loc 2 187 0
 784 02b6 8FE9      		ldi r24,lo8(3999)
 785 02b8 9FE0      		ldi r25,hi8(3999)
 786 02ba 0197      	1:	sbiw r24,1
 787 02bc 01F4      		brne 1b
 788 02be 00C0      		rjmp .
 789 02c0 0000      		nop
 790 02c2 2196      		adiw r28,1
 791               	.LBE71:
 792               	.LBE70:
 183:main.c        **** 		//while(get_lcd_busy_flag() > 0);	
 793               		.loc 1 183 0
 794 02c4 F501      		movw r30,r10
 795 02c6 8081      		ld r24,Z
 796 02c8 0E94 0000 		call put_lcd_data
 186:main.c        **** 			
 797               		.loc 1 186 0
 798 02cc 1F92      		push __zero_reg__
 799               	.LCFI72:
 800               		.cfi_def_cfa_offset 17
 801 02ce FF92      		push r15
 802               	.LCFI73:
 803               		.cfi_def_cfa_offset 18
 804 02d0 EF92      		push r14
 805               	.LCFI74:
 806               		.cfi_def_cfa_offset 19
 807 02d2 1F92      		push __zero_reg__
 808               	.LCFI75:
 809               		.cfi_def_cfa_offset 20
 810 02d4 DF92      		push r13
 811               	.LCFI76:
 812               		.cfi_def_cfa_offset 21
 813 02d6 0E94 0000 		call clear_bits
 188:main.c        **** 		{
 814               		.loc 1 188 0
 815 02da 8DB7      		in r24,__SP_L__
 816 02dc 9EB7      		in r25,__SP_H__
 817 02de 0A96      		adiw r24,10
 818 02e0 0FB6      		in __tmp_reg__,__SREG__
 819 02e2 F894      		cli
 820 02e4 9EBF      		out __SP_H__,r25
 821 02e6 0FBE      		out __SREG__,__tmp_reg__
 822 02e8 8DBF      		out __SP_L__,r24
 823               	.LCFI77:
 824               		.cfi_def_cfa_offset 11
 825 02ea 0F30      		cpi r16,15
 826 02ec 1105      		cpc r17,__zero_reg__
 827 02ee 01F4      		brne .L83
 192:main.c        **** 		//while(get_lcd_busy_flag() > 0);
 828               		.loc 1 192 0
 829 02f0 80EC      		ldi r24,lo8(-64)
 830 02f2 0E94 0000 		call put_lcd_data
 831               	.L83:
 196:main.c        **** 		
 832               		.loc 1 196 0
 833 02f6 0F5F      		subi r16,-1
 834 02f8 1F4F      		sbci r17,-1
 835 02fa 00C0      		rjmp .L82
 836               	.L85:
 837               	/* epilogue start */
 200:main.c        **** 	
 838               		.loc 1 200 0
 839 02fc DF91      		pop r29
 840 02fe CF91      		pop r28
 841 0300 1F91      		pop r17
 842 0302 0F91      		pop r16
 843 0304 FF90      		pop r15
 844 0306 EF90      		pop r14
 845 0308 DF90      		pop r13
 846 030a BF90      		pop r11
 847 030c AF90      		pop r10
 848 030e 0895      		ret
 849               		.cfi_endproc
 850               	.LFE13:
 852               		.section	.rodata.str1.1,"aMS",@progbits,1
 853               	.LC0:
 854 0000 4E61 2064 		.string	"Na das war aber eine schwere Geburt"
 854      6173 2077 
 854      6172 2061 
 854      6265 7220 
 854      6569 6E65 
 855               	.LC1:
 856 0024 556E 6420 		.string	"Und das alles wegen einem schlechten Datenblatt..."
 856      6461 7320 
 856      616C 6C65 
 856      7320 7765 
 856      6765 6E20 
 857               	.LC2:
 858 0057 444D 5347 		.string	"DMSG: PORTB:%x"
 858      3A20 504F 
 858      5254 423A 
 858      2578 00
 859               	.LC3:
 860 0066 5345 4E53 		.string	"SENSOR: %x"
 860      4F52 3A20 
 860      2578 00
 861               		.section	.text.startup,"ax",@progbits
 862               	.global	main
 864               	main:
 865               	.LFB11:
  34:main.c        **** 
 866               		.loc 1 34 0
 867               		.cfi_startproc
 868 0000 CF93      		push r28
 869               	.LCFI78:
 870               		.cfi_def_cfa_offset 3
 871               		.cfi_offset 28, -2
 872 0002 DF93      		push r29
 873               	.LCFI79:
 874               		.cfi_def_cfa_offset 4
 875               		.cfi_offset 29, -3
 876 0004 CDB7      		in r28,__SP_L__
 877 0006 DEB7      		in r29,__SP_H__
 878               	.LCFI80:
 879               		.cfi_def_cfa_register 28
 880 0008 A897      		sbiw r28,40
 881               	.LCFI81:
 882               		.cfi_def_cfa_offset 44
 883 000a 0FB6      		in __tmp_reg__,__SREG__
 884 000c F894      		cli
 885 000e DEBF      		out __SP_H__,r29
 886 0010 0FBE      		out __SREG__,__tmp_reg__
 887 0012 CDBF      		out __SP_L__,r28
 888               	/* prologue: function */
 889               	/* frame size = 40 */
 890               	/* stack size = 42 */
 891               	.L__stack_usage = 42
 892               	.LVL47:
 893               	.LBB72:
 894               	.LBB73:
 895               		.loc 2 187 0
 896 0014 2FEF      		ldi r18,lo8(63999)
 897 0016 89EF      		ldi r24,hi8(63999)
 898 0018 90E0      		ldi r25,hlo8(63999)
 899 001a 2150      	1:	subi r18,1
 900 001c 8040      		sbci r24,0
 901 001e 9040      		sbci r25,0
 902 0020 01F4      		brne 1b
 903 0022 00C0      		rjmp .
 904 0024 0000      		nop
 905               	.LVL48:
 906               	.LBE73:
 907               	.LBE72:
  42:main.c        **** 	
 908               		.loc 1 42 0
 909 0026 0E94 0000 		call configurate_pins
 910               	.LVL49:
  44:main.c        ****             
 911               		.loc 1 44 0
 912 002a 8FEF      		ldi r24,lo8(-1)
 913 002c 84B9      		out 0x4,r24
  46:main.c        **** 
 914               		.loc 1 46 0
 915 002e 8AB9      		out 0xa,r24
  50:main.c        ****    _delay_ms (10); 
 916               		.loc 1 50 0
 917 0030 1F92      		push __zero_reg__
 918 0032 83E0      		ldi r24,lo8(3)
 919 0034 8F93      		push r24
 920 0036 1F92      		push __zero_reg__
 921 0038 82E0      		ldi r24,lo8(2)
 922 003a 8F93      		push r24
 923 003c 8F93      		push r24
 924 003e 1F92      		push __zero_reg__
 925 0040 8BE2      		ldi r24,lo8(43)
 926 0042 8F93      		push r24
 927 0044 0E94 0000 		call clear_bits
 928               	.LVL50:
 929               	.LBB74:
 930               	.LBB75:
 931               		.loc 2 187 0
 932 0048 8FE3      		ldi r24,lo8(-25537)
 933 004a 9CE9      		ldi r25,hi8(-25537)
 934 004c 0197      	1:	sbiw r24,1
 935 004e 01F4      		brne 1b
 936 0050 00C0      		rjmp .
 937 0052 0000      		nop
 938               	.LVL51:
 939               	.LBE75:
 940               	.LBE74:
  53:main.c        **** _delay_ms (4.1);
 941               		.loc 1 53 0
 942 0054 83E0      		ldi r24,lo8(3)
 943 0056 0E94 0000 		call put_lcd_nibble
 944               	.LVL52:
 945               	.LBB76:
 946               	.LBB77:
 947               		.loc 2 187 0
 948 005a 8FE0      		ldi r24,lo8(16399)
 949 005c 90E4      		ldi r25,hi8(16399)
 950 005e 0197      	1:	sbiw r24,1
 951 0060 01F4      		brne 1b
 952 0062 00C0      		rjmp .
 953 0064 0000      		nop
 954               	.LVL53:
 955               	.LBE77:
 956               	.LBE76:
  56:main.c        **** _delay_us (100);
 957               		.loc 1 56 0
 958 0066 83E0      		ldi r24,lo8(3)
 959 0068 0E94 0000 		call put_lcd_nibble
 960               	.LVL54:
 961               	.LBB78:
 962               	.LBB79:
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 963               		.loc 2 276 0
 964 006c 8FE8      		ldi r24,lo8(399)
 965 006e 91E0      		ldi r25,hi8(399)
 966 0070 0197      	1:	sbiw r24,1
 967 0072 01F4      		brne 1b
 968 0074 00C0      		rjmp .
 969 0076 0000      		nop
 970               	.LVL55:
 971               	.LBE79:
 972               	.LBE78:
  63:main.c        **** _delay_ms (4.1);
 973               		.loc 1 63 0
 974 0078 83E0      		ldi r24,lo8(3)
 975 007a 0E94 0000 		call put_lcd_nibble
 976               	.LVL56:
 977               	.LBB80:
 978               	.LBB81:
 187:/usr/lib/avr/include/util/delay.h **** 
 979               		.loc 2 187 0
 980 007e 8FE0      		ldi r24,lo8(16399)
 981 0080 90E4      		ldi r25,hi8(16399)
 982 0082 0197      	1:	sbiw r24,1
 983 0084 01F4      		brne 1b
 984 0086 00C0      		rjmp .
 985 0088 0000      		nop
 986               	.LVL57:
 987               	.LBE81:
 988               	.LBE80:
  65:main.c        **** _delay_ms (4.1);
 989               		.loc 1 65 0
 990 008a 82E0      		ldi r24,lo8(2)
 991 008c 0E94 0000 		call put_lcd_nibble
 992               	.LVL58:
 993               	.LBB82:
 994               	.LBB83:
 187:/usr/lib/avr/include/util/delay.h **** 
 995               		.loc 2 187 0
 996 0090 8FE0      		ldi r24,lo8(16399)
 997 0092 90E4      		ldi r25,hi8(16399)
 998 0094 0197      	1:	sbiw r24,1
 999 0096 01F4      		brne 1b
 1000 0098 00C0      		rjmp .
 1001 009a 0000      		nop
 1002               	.LVL59:
 1003               	.LBE83:
 1004               	.LBE82:
  70:main.c        **** 
 1005               		.loc 1 70 0
 1006 009c 88E2      		ldi r24,lo8(40)
 1007 009e 0E94 0000 		call put_lcd_data
 1008               	.LVL60:
  74:main.c        **** 
 1009               		.loc 1 74 0
 1010 00a2 88E0      		ldi r24,lo8(8)
 1011 00a4 0E94 0000 		call put_lcd_data
 1012               	.LVL61:
  76:main.c        **** 
 1013               		.loc 1 76 0
 1014 00a8 81E0      		ldi r24,lo8(1)
 1015 00aa 0E94 0000 		call put_lcd_data
 1016               	.LVL62:
  80:main.c        **** 
 1017               		.loc 1 80 0
 1018 00ae 86E0      		ldi r24,lo8(6)
 1019 00b0 0E94 0000 		call put_lcd_data
 1020               	.LVL63:
  83:main.c        **** 
 1021               		.loc 1 83 0
 1022 00b4 8FE0      		ldi r24,lo8(15)
 1023 00b6 0E94 0000 		call put_lcd_data
 1024               	.LVL64:
  94:main.c        ****    	 _delay_ms (2000);
 1025               		.loc 1 94 0
 1026 00ba 80E0      		ldi r24,lo8(.LC0)
 1027 00bc 90E0      		ldi r25,hi8(.LC0)
 1028 00be 0E94 0000 		call lcd_write_string
 1029               	.LVL65:
 1030               	.LBB84:
 1031               	.LBB85:
 187:/usr/lib/avr/include/util/delay.h **** 
 1032               		.loc 2 187 0
 1033 00c2 9FEF      		ldi r25,lo8(6399999)
 1034 00c4 27EA      		ldi r18,hi8(6399999)
 1035 00c6 81E6      		ldi r24,hlo8(6399999)
 1036 00c8 9150      	1:	subi r25,1
 1037 00ca 2040      		sbci r18,0
 1038 00cc 8040      		sbci r24,0
 1039 00ce 01F4      		brne 1b
 1040 00d0 00C0      		rjmp .
 1041 00d2 0000      		nop
 1042               	.LVL66:
 1043               	.LBE85:
 1044               	.LBE84:
  97:main.c        ****   
 1045               		.loc 1 97 0
 1046 00d4 81E0      		ldi r24,lo8(1)
 1047 00d6 0E94 0000 		call put_lcd_data
 1048               	.LVL67:
 100:main.c        **** 	_delay_ms (2000);
 1049               		.loc 1 100 0
 1050 00da 80E0      		ldi r24,lo8(.LC1)
 1051 00dc 90E0      		ldi r25,hi8(.LC1)
 1052 00de 0E94 0000 		call lcd_write_string
 1053               	.LVL68:
 1054               	.LBB86:
 1055               	.LBB87:
 187:/usr/lib/avr/include/util/delay.h **** 
 1056               		.loc 2 187 0
 1057 00e2 9FEF      		ldi r25,lo8(6399999)
 1058 00e4 27EA      		ldi r18,hi8(6399999)
 1059 00e6 81E6      		ldi r24,hlo8(6399999)
 1060 00e8 9150      	1:	subi r25,1
 1061 00ea 2040      		sbci r18,0
 1062 00ec 8040      		sbci r24,0
 1063 00ee 01F4      		brne 1b
 1064 00f0 00C0      		rjmp .
 1065 00f2 0000      		nop
 1066               	.LVL69:
 1067               	.LBE87:
 1068               	.LBE86:
 102:main.c        **** 	
 1069               		.loc 1 102 0
 1070 00f4 81E0      		ldi r24,lo8(1)
 1071 00f6 0E94 0000 		call put_lcd_data
 1072               	.LVL70:
 105:main.c        **** 	lcd_write_string(formatted_string);
 1073               		.loc 1 105 0
 1074 00fa 85B1      		in r24,0x5
 1075 00fc 1F92      		push __zero_reg__
 1076 00fe 8F93      		push r24
 1077 0100 80E0      		ldi r24,lo8(.LC2)
 1078 0102 90E0      		ldi r25,hi8(.LC2)
 1079 0104 9F93      		push r25
 1080 0106 8F93      		push r24
 1081 0108 8E01      		movw r16,r28
 1082 010a 0F5F      		subi r16,-1
 1083 010c 1F4F      		sbci r17,-1
 1084 010e 1F93      		push r17
 1085 0110 0F93      		push r16
 1086 0112 0E94 0000 		call sprintf
 1087               	.LVL71:
 106:main.c        **** 	_delay_ms (2000);
 1088               		.loc 1 106 0
 1089 0116 C801      		movw r24,r16
 1090 0118 0E94 0000 		call lcd_write_string
 1091               	.LVL72:
 1092               	.LBB88:
 1093               	.LBB89:
 187:/usr/lib/avr/include/util/delay.h **** 
 1094               		.loc 2 187 0
 1095 011c 9FEF      		ldi r25,lo8(6399999)
 1096 011e 27EA      		ldi r18,hi8(6399999)
 1097 0120 81E6      		ldi r24,hlo8(6399999)
 1098 0122 9150      	1:	subi r25,1
 1099 0124 2040      		sbci r18,0
 1100 0126 8040      		sbci r24,0
 1101 0128 01F4      		brne 1b
 1102 012a 00C0      		rjmp .
 1103 012c 0000      		nop
 1104               	.LVL73:
 1105               	.LBE89:
 1106               	.LBE88:
 110:main.c        **** 	_delay_ms (20);
 1107               		.loc 1 110 0
 1108 012e 2298      		cbi 0x4,2
 1109               	.LVL74:
 1110               	.LBB90:
 1111               	.LBB91:
 187:/usr/lib/avr/include/util/delay.h **** 
 1112               		.loc 2 187 0
 1113 0130 9FEF      		ldi r25,lo8(63999)
 1114 0132 29EF      		ldi r18,hi8(63999)
 1115 0134 80E0      		ldi r24,hlo8(63999)
 1116 0136 9150      	1:	subi r25,1
 1117 0138 2040      		sbci r18,0
 1118 013a 8040      		sbci r24,0
 1119 013c 01F4      		brne 1b
 1120 013e 00C0      		rjmp .
 1121 0140 0000      		nop
 1122               	.LVL75:
 1123               	.LBE91:
 1124               	.LBE90:
 114:main.c        **** 		
 1125               		.loc 1 114 0
 1126 0142 81E0      		ldi r24,lo8(1)
 1127 0144 0E94 0000 		call put_lcd_data
 1128               	.LVL76:
 1129 0148 0FB6      		in __tmp_reg__,__SREG__
 1130 014a F894      		cli
 1131 014c DEBF      		out __SP_H__,r29
 1132 014e 0FBE      		out __SREG__,__tmp_reg__
 1133 0150 CDBF      		out __SP_L__,r28
 121:main.c        **** 	lcd_write_string(formatted_string);
 1134               		.loc 1 121 0
 1135 0152 80E0      		ldi r24,lo8(.LC3)
 1136 0154 E82E      		mov r14,r24
 1137 0156 80E0      		ldi r24,hi8(.LC3)
 1138 0158 F82E      		mov r15,r24
 1139               	.L87:
 119:main.c        ****         
 1140               		.loc 1 119 0 discriminator 1
 1141 015a 80E0      		ldi r24,0
 1142 015c 0E94 0000 		call debug_pin
 1143               	.LVL77:
 121:main.c        **** 	lcd_write_string(formatted_string);
 1144               		.loc 1 121 0 discriminator 1
 1145 0160 83B1      		in r24,0x3
 1146 0162 8470      		andi r24,lo8(4)
 1147 0164 1F92      		push __zero_reg__
 1148 0166 8F93      		push r24
 1149 0168 FF92      		push r15
 1150 016a EF92      		push r14
 1151 016c 1F93      		push r17
 1152 016e 0F93      		push r16
 1153 0170 0E94 0000 		call sprintf
 1154               	.LVL78:
 122:main.c        **** 	
 1155               		.loc 1 122 0 discriminator 1
 1156 0174 C801      		movw r24,r16
 1157 0176 0E94 0000 		call lcd_write_string
 1158               	.LVL79:
 124:main.c        **** 	//while(get_lcd_busy_flag() > 0);
 1159               		.loc 1 124 0 discriminator 1
 1160 017a 80EC      		ldi r24,lo8(-64)
 1161 017c 0E94 0000 		call put_lcd_data
 1162               	.LVL80:
 1163               	.LBB92:
 1164               	.LBB93:
 187:/usr/lib/avr/include/util/delay.h **** 
 1165               		.loc 2 187 0 discriminator 1
 1166 0180 9FEF      		ldi r25,lo8(3199999)
 1167 0182 23ED      		ldi r18,hi8(3199999)
 1168 0184 80E3      		ldi r24,hlo8(3199999)
 1169 0186 9150      	1:	subi r25,1
 1170 0188 2040      		sbci r18,0
 1171 018a 8040      		sbci r24,0
 1172 018c 01F4      		brne 1b
 1173 018e 00C0      		rjmp .
 1174 0190 0000      		nop
 1175 0192 0F90      		pop __tmp_reg__
 1176 0194 0F90      		pop __tmp_reg__
 1177 0196 0F90      		pop __tmp_reg__
 1178 0198 0F90      		pop __tmp_reg__
 1179 019a 0F90      		pop __tmp_reg__
 1180 019c 0F90      		pop __tmp_reg__
 1181 019e 00C0      		rjmp .L87
 1182               	.LBE93:
 1183               	.LBE92:
 1184               		.cfi_endproc
 1185               	.LFE11:
 1187               		.comm	LCD_EN_test,3,1
 1188               		.text
 1189               	.Letext0:
 1190               		.file 3 "/usr/lib/avr/include/stdint.h"
 1191               		.file 4 "lcd_1602A.h"
 1192               		.file 5 "atmel_io_control.h"
 1193               		.file 6 "atmel_pin_config.h"
 1194               		.file 7 "/usr/lib/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccx1d1M2.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccx1d1M2.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccx1d1M2.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccx1d1M2.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccx1d1M2.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccx1d1M2.s:12     .text:0000000000000000 put_lcd_nibble
     /tmp/ccx1d1M2.s:91     .text:0000000000000046 debug_pin
     /tmp/ccx1d1M2.s:159    .text:000000000000008c get_lcd_busy_flag
     /tmp/ccx1d1M2.s:507    .text:00000000000001d2 put_lcd_data
                            *COM*:0000000000000003 LCD_EN_test
     /tmp/ccx1d1M2.s:599    .text:0000000000000224 lcd_write
     /tmp/ccx1d1M2.s:703    .text:000000000000027c lcd_write_string
     /tmp/ccx1d1M2.s:864    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
toggle_LCD_EN
clear_bits
set_bits
toggle_LCD_EN_test
configurate_pins
sprintf
__do_copy_data
__do_clear_bss
